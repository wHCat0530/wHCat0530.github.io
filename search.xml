<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Unity游戏开发Mathf函数描述整理</title>
      <link href="/2022/09/04/unity-you-xi-kai-fa-mathf-han-shu-miao-shu-zheng-li/"/>
      <url>/2022/09/04/unity-you-xi-kai-fa-mathf-han-shu-miao-shu-zheng-li/</url>
      
        <content type="html"><![CDATA[<h1 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h1><h4 id="Mathf-Deg2Rad"><a href="#Mathf-Deg2Rad" class="headerlink" title="Mathf.Deg2Rad"></a>Mathf.Deg2Rad</h4><p>读到弧度的换算常量（只读），等于公式 (PI*2)/360</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using UnityEngine;using System.Collections;public class ExampleClass:MonoBehaviour{public float deg=30.0F;void Start(){float rad=def*Mathf.Deg2Rad;Debug.Log(deg+"degrees are equal to"+rad+"radians.");}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Mathf-Epsilon"><a href="#Mathf-Epsilon" class="headerlink" title="Mathf.Epsilon"></a>Mathf.Epsilon</h4><p>微小浮点值（只读），浮点数可以与0相差的最小值</p><p>介于任何数字与Epsilon之间的值会产生任意数字，因为存在截断误差。</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using UnityEngine;public class Example:MonoBehaviour{// Compares two floating point numbers and return true if they are the same number.    // See also Mathf.Approximately, which compares floating point numbers so you dont have    // to create a function to compare them.        bool isEqual(float a,float b)    {    if(a&gt;=b-Math.Epsilon &amp;&amp;a&lt;=b+Mathf.Epsilon)    {    return true;    }    else    {    return false;    }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Mathf-Infinity"><a href="#Mathf-Infinity" class="headerlink" title="Mathf.Infinity"></a>Mathf.Infinity</h4><p>正无穷大的表示形式（只读）</p><pre class="line-numbers language-C#" data-language="C#"><code class="language-C#">using UnityEngine;public class Example:MonoBehaviour{// Casts a ray from (0,0,0) towards (0,0,1) to the infinity and prints a message    // if any object has touched the ray.    // To test it, just place any object and intersect it with the white drawn line        void Update()    {//shows the line that follows the ray.Debug.DrawLine(Vector3.zero,Vector3.forward*100);if(Physics.Raycast(Vector3.zero,Vector3.forward,Mathf.Infinity)){print("There is something in front of the object!");}}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Mathf-NegativeInfinity"><a href="#Mathf-NegativeInfinity" class="headerlink" title="Mathf.NegativeInfinity"></a>Mathf.NegativeInfinity</h4><p>负无穷大的表示形式（只读）</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using UnityEngine;public class Example:MonoBehaviour{void Start(){Debug.Log(Mathf.NegativeInfinity);}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Math-PI"><a href="#Math-PI" class="headerlink" title="Math.PI"></a>Math.PI</h4><p>圆周率函数，该数值是32位浮点数，是float，可以提供大约七位数的精度</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using UnityEngine;using System.Collections;public class ExampleClass:MonoBehaviour{public float radius=5;void Start(){float perimeter=2.0f*Mathf.PI*radius;Debug.Log("The perimeter of the circle is:"+perimeter);}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Mathf-Rad2Deg"><a href="#Mathf-Rad2Deg" class="headerlink" title="Mathf.Rad2Deg"></a>Mathf.Rad2Deg</h4><p>弧度到度的换算常量（只读），公式等于360/(PI*2)</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using UnityEngine;public class MathfRad2Deg:MonoBehaviour{//convert 1 radian to degreesfloat rad=1.0f;void Start(){float deg=rad*Mathf.Rad2Deg;//This will output 1 radians are equal to 57.29578 degreesDebug.Log(rad+"radians are equal to"+deg+"degrees.");}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="静态函数"><a href="#静态函数" class="headerlink" title="静态函数"></a>静态函数</h1><h4 id="Mathf-Abs"><a href="#Mathf-Abs" class="headerlink" title="Mathf.Abs"></a>Mathf.Abs</h4><p>可以用来返回 f 的绝对值</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using UnityEngine;public class MathAbsExample:Monohaviour{void Start(){// prints 10.5Debug.Log(Mathf.Abs(-10.5f));// prints 10Debug.Log(Mathf.Abs(-10));}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Mathf-Acos"><a href="#Mathf-Acos" class="headerlink" title="Mathf.Acos"></a>Mathf.Acos</h4><p>返回 f 的反余弦-其余弦为 f 的角度（以弧度为单位）</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using UnityEngine;public class ScriptExample:MonoBehaviour{void Start(){print(Mathf.Acos(0.5f));}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Mathf-Approximately"><a href="#Mathf-Approximately" class="headerlink" title="Mathf.Approximately"></a>Mathf.Approximately</h4><p>比较两个浮点数，如果两个浮点数相似，则返回true，比较的差值处于Epsilon范围内则返回True</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using UnityEngine;public class ScriptExample:MonoBehaviour{void Start(){if(Mathf.Approximately(1.0f,10.0f/10.0f)){print("The values are approximately the same");}}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Mathf-Asin"><a href="#Mathf-Asin" class="headerlink" title="Mathf.Asin"></a>Mathf.Asin</h4><p>返回 f 的反正弦-其正弦为 f 的角度（以弧度为单位）</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using UnityEngine;public class ScriptExample:MonoBehaviour{void Start(){print(Mathf.Asin(0.5f));}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Mathf-Atan"><a href="#Mathf-Atan" class="headerlink" title="Mathf.Atan"></a>Mathf.Atan</h4><p>返回 f 的反正切-其正切为 f 的角度（以弧度为单位）</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using UnityEngine;public class ScriptExample:MonoBehaviour{void Start(){print(Mathf.Atan(0.5f));}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Mathf-Ceil"><a href="#Mathf-Ceil" class="headerlink" title="Mathf.Ceil"></a>Mathf.Ceil</h4><p>返回大于或等于 f 的最小整数</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using UnityEngine;using System.Collections;public class ExampleClass:MonoBehaviour{void Example(){        // Prints 10        Debug.Log(Mathf.Ceil(10.0F));        // Prints 11        Debug.Log(Mathf.Ceil(10.2F));        // Prints 11        Debug.Log(Mathf.Ceil(10.7F));        // Prints -10        Debug.Log(Mathf.Ceil(-10.0F));        // Prints -10        Debug.Log(Mathf.Ceil(-10.2F));        // Prints -10        Debug.Log(Mathf.Ceil(-10.7F));}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Mathf-CeilToInt"><a href="#Mathf-CeilToInt" class="headerlink" title="Mathf.CeilToInt"></a>Mathf.CeilToInt</h4><p>返回大于或等于 f 的最小整数</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using UnityEngine;using System.Collections;public class ExampleClass : MonoBehaviour{    void Start()    {        // Prints 10        Debug.Log(Mathf.CeilToInt(10.0f));        // Prints 11        Debug.Log(Mathf.CeilToInt(10.2f));        // Prints 11        Debug.Log(Mathf.CeilToInt(10.7f));        // Prints -10        Debug.Log(Mathf.CeilToInt(-10.0f));        // Prints -10        Debug.Log(Mathf.CeilToInt(-10.2f));        // Prints -10        Debug.Log(Mathf.CeilToInt(-10.7f));    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Mathf-Clamp"><a href="#Mathf-Clamp" class="headerlink" title="Mathf.Clamp"></a>Mathf.Clamp</h4><p>用于返回 float 最小值和最大值之间的浮点结果</p><p>将给定制限制在给定的最小浮点数和最大浮点数之间。如果它在最小和最大的范围内 则返回给定值。如果给定的浮点值小于最小值则返回最小值。如果给定值大于最大值，则返回最大值。</p><p>如果最小值大于最大值则该方法返回最小值。</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using UnityEngine;// Mathf.Clamp example.//// Animate a cube along the x-axis using a sine wave.// Let the minimum and maximum positions on the x-axis// be changed.  The cube will be visible inside the// minimum and maximum values.public class ExampleScript:MonoBehaviour{private float xMin-0.5f,xMax=5.0f;private float timeValue=0.0f;void Update(){// Compute the sin position.float xValue=Mathf.Sin(timeValue*5.0f);// Now compute the Clamp value.float xPos=Mathf.Clamp(xValue,xMin,xMax);// Update the position of the cube.transform.position=new Vector3(xPos,0.0f,0.0f);// Increase animation time.timeValue=timeValue+Time.deltaTime;// Reset the animation time if it is greater than theplanned time.if(xValue&gt;Mathf.PI*2.0f){timeValue=0.0f;}}void OnGUI(){// Let the minimum and maximum values be changed        xMin = GUI.HorizontalSlider(new Rect(25, 25, 100, 30), xMin, -1.0f, +1.0f);        xMax = GUI.HorizontalSlider(new Rect(25, 60, 100, 30), xMax, -1.0f, +1.0f);        // xMin is kept less-than or equal to xMax.        if (xMin &gt; xMax)        {            xMin = xMax;        }        // Display the xMin and xMax value with better size labels.        GUIStyle fontSize = new GUIStyle(GUI.skin.GetStyle("label"));        fontSize.fontSize = 24;        GUI.Label(new Rect(135, 10, 150, 30), "xMin: " + xMin.ToString("f2"), fontSize);        GUI.Label(new Rect(135, 45, 150, 30), "xMax: " + xMax.ToString("f2"), fontSize);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同样该函数还可以用作与返回 int 最小值到最大值之间的整数结果</p><p>如果 给定值在最小和最大的范围内，则返回给定值，如给定值小于最小值，则返回最小值。如果给定值大于最大值，则直接返回最大值。Min和Max参数包括在内，例如Clamp(10,0,5)将返回最大参数为5，而不是4。</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using UnityEngine;// Mathf.Clamp integer example.//// Add or subtract values from health.// Keep health between 1 and 100. Start at 17.public class ExampleScript : MonoBehaviour{    public int health = 17;    private int[] healthUp = new int[] {25, 10, 5, 1};    private int[] healthDown = new int[] {-10, -5, -2, -1};    // Width and height for the buttons.    private int xButton = 75;    private int yButton = 50;    // Place of the top left button.    private int xPos1 = 50, yPos1 = 100;    private int xPos2 = 125, yPos2 = 100;    void OnGUI()    {        GUI.skin.label.fontSize = 20;        GUI.skin.button.fontSize = 20;        // Generate and show positive buttons.        for (int i = 0; i &lt; healthUp.Length; i++)        {            if (GUI.Button(new Rect(xPos1, yPos1 + i * yButton, xButton, yButton), healthUp[i].ToString()))            {                health += healthUp[i];            }        }        // Generate and show negative buttons.        for (int i = 0; i &lt; healthDown.Length; i++)        {            if (GUI.Button(new Rect(xPos2, yPos2 + i * yButton, xButton, yButton), healthDown[i].ToString()))            {                health += healthDown[i];            }        }        // Show health between 1 and 100.        health = Mathf.Clamp(health, 1, 100);        GUI.Label(new Rect(xPos1, xPos1, 2 * xButton, yButton), "Health: " + health.ToString("D3"));    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Mathf-Clamp01"><a href="#Mathf-Clamp01" class="headerlink" title="Mathf.Clamp01"></a>Mathf.Clamp01</h4><p>将值限制在0和1之间并返回值，如果值为负，则返回0。如果值大于1，则返回1。</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using UnityEngine;public class Example:MonoBehaviour{// Set the position of the transform to be that of the time    // but never less than 0 or more than 1        void Update()    {    transform.position=new Vector3(Mathf.Clamp01(Time.time),0,0);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using System.Collections;using System.Collections.Generic;using UnityEngine;// Print a random number every second.  This number is chosen over a// range from startValue to endValue.  The random number is clamped// to between zero and one by Clamp01().public class ExampleScript:MonoBehaviour{public float startValue=-0.5f;public float endValue=1.5f;private float timeCount=0.0f;void FixedUpdate(){timeCount+=Time.deltaTime;if(timeCount&gt;1.0f){float result=Random.value;result=result*(endValue-startValue);result=result+startValue;float clampValue=Mathf.Clamp01(result); Debug.Log("value:"+result.ToString("F3")+"result:"+clampValue.ToString("F3"));timeCount=0.0f;}}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Mathf-ClosestPowerOfTwo"><a href="#Mathf-ClosestPowerOfTwo" class="headerlink" title="Mathf.ClosestPowerOfTwo"></a>Mathf.ClosestPowerOfTwo</h4><p>返回最接近的 2 的幂值</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using UnityEngine;public class Example:MonoBegaviour{void Start(){// prints 8Debug.Log(Mathf.ClosestPowerOfTwo(7));// prints 16Debug.Log(Mathf.ClosestPowerOfTwo(19));}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Mathf-CorrelatedColorTemperatureToRGB"><a href="#Mathf-CorrelatedColorTemperatureToRGB" class="headerlink" title="Mathf.CorrelatedColorTemperatureToRGB"></a>Mathf.CorrelatedColorTemperatureToRGB</h4><p>参数：kelvin 以开尔文为单位的温度</p><p>返回一个Color采用浮点RGB眼色行事的相关色温</p><p>该函数以开尔文为单位的色温转换为RGB颜色，给定相关色温，估算RGB等效值。曲线拟合误差最大为0.008</p><p>参数返回必须处于1000到40000度之间。</p><h4 id="Mathf-Cos"><a href="#Mathf-Cos" class="headerlink" title="Mathf.Cos"></a>Mathf.Cos</h4><p>返回角度 f 的余弦，返回值 float 介于 -1 和 1 之间。</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using UnityEngine;using System.Collections;public class PolyDrawExample : MonoBehaviour{    public int numberOfSides;    public float polygonRadius;    public Vector2 polygonCenter;    void Update()    {        DebugDrawPolygon(polygonCenter, polygonRadius, numberOfSides);    }    // Draw a polygon in the XY plane with a specfied position, number of sides    // and radius.    void DebugDrawPolygon(Vector2 center, float radius, int numSides)    {        // The corner that is used to start the polygon (parallel to the X axis).        Vector2 startCorner = new Vector2(radius, 0) + center;        // The "previous" corner point, initialised to the starting corner.        Vector2 previousCorner = startCorner;        // For each corner after the starting corner...        for (int i = 1; i &lt; numSides; i++)        {            // Calculate the angle of the corner in radians.            float cornerAngle = 2f * Mathf.PI / (float)numSides * i;            // Get the X and Y coordinates of the corner point.            Vector2 currentCorner = new Vector2(Mathf.Cos(cornerAngle) * radius, Mathf.Sin(cornerAngle) * radius) + center;            // Draw a side of the polygon by connecting the current corner to the previous one.            Debug.DrawLine(currentCorner, previousCorner);            // Having used the current corner, it now becomes the previous corner.            previousCorner = currentCorner;        }        // Draw the final side by connecting the last corner to the starting corner.        Debug.DrawLine(startCorner, previousCorner);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Mathf-DeltaAngle"><a href="#Mathf-DeltaAngle" class="headerlink" title="Mathf.DeltaAngle"></a>Mathf.DeltaAngle</h4><p>计算两个给定角度（以度为单位给定）之间的最短差异。</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using UnityEngine;public class Example:MonoBehaviour{void Start(){// prints 90Debug.Log(Mathf.DeltaAngle(1080,90))}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Mathf-Exp"><a href="#Mathf-Exp" class="headerlink" title="Mathf.Exp"></a>Mathf.Exp</h4><p>返回 e 的制定幂</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using UnityEngine;public class Example:MonoBehaviour{void Start(){print(Mathf.Exp(6));}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Mathf-FloatToHalf"><a href="#Mathf-FloatToHalf" class="headerlink" title="Mathf.FloatToHalf"></a>Mathf.FloatToHalf</h4><p>返回无符号短整型（ushort）转换后的版精度浮点数，储存在16为无符号整数中</p><h4 id="Mathf-Floor"><a href="#Mathf-Floor" class="headerlink" title="Mathf.Floor"></a>Mathf.Floor</h4><p>返回小于或等于 f 的最大整数</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using UnityEngine;using System.Collections;public class ExampleClass：MonoBehaviour{void Example(){        Debug.Log(Mathf.Floor(10.0F));   // Prints  10        Debug.Log(Mathf.Floor(10.2F));   // Prints  10        Debug.Log(Mathf.Floor(10.7F));   // Prints  10        Debug.Log(Mathf.Floor(-10.0F));  // Prints -10        Debug.Log(Mathf.Floor(-10.2F));  // Prints -11        Debug.Log(Mathf.Floor(-10.7F));  // Prints -11}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Mathf-FloorToInt"><a href="#Mathf-FloorToInt" class="headerlink" title="Mathf.FloorToInt"></a>Mathf.FloorToInt</h4><p>返回小于或等于 f 的最大整数</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using unityEngine;using System.Collections;public class ExampleClass:MonoBehaviour{void Example(){Debug.Log(Mathf.FloorToInt(10.0F));  // Prints  10        Debug.Log(Mathf.FloorToInt(10.2F));  // Prints  10        Debug.Log(Mathf.FloorToInt(10.7F));  // Prints  10        Debug.Log(Mathf.FloorToInt(-10.0F)); // Prints -10        Debug.Log(Mathf.FloorToInt(-10.2F)); // Prints -11        Debug.Log(Mathf.FloorToInt(-10.7F)); // Prints -11}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Mathf-GammaToLinearSpace"><a href="#Mathf-GammaToLinearSpace" class="headerlink" title="Mathf.GammaToLinearSpace"></a>Mathf.GammaToLinearSpace</h4><p>将给定制从伽马（sRGB）转换为线性颜色空间</p><h4 id="Mathf-HalfToFloat"><a href="#Mathf-HalfToFloat" class="headerlink" title="Mathf.HalfToFloat"></a>Mathf.HalfToFloat</h4><p>返回 float 解码后的32为浮点数</p><h4 id="Mathf-InverseLerp"><a href="#Mathf-InverseLerp" class="headerlink" title="Mathf.InverseLerp"></a>Mathf.InverseLerp</h4><p>返回值为 float 返回了一个介于0和1之间的值。表示“value”参数在a和b定义的范围内的位置。</p><p>用于确定value位于a b两点之间的位置</p><h4 id="Mathf-IsPowerOfTwo"><a href="#Mathf-IsPowerOfTwo" class="headerlink" title="Mathf.IsPowerOfTwo"></a>Mathf.IsPowerOfTwo</h4><p>如果值是 2 的幂，则返回 true</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using unityEngine;public class Example:MonoBehaviour{void Start(){// prints flaseDebug.Log(Mathf.IsPowerOfTwo(7));// prints trueDebug.Log(Mathf.IsPowerOfTwo(32));}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Mathf-Lerp"><a href="#Mathf-Lerp" class="headerlink" title="Mathf.Lerp"></a>Mathf.Lerp</h4><p>在 a 和 b 之间按照 t 进行线性插值，参数 t 限制在范围[0,1]内。</p><p>当t=0时，返回a、当t=1时，返回b、当t=0.5时，返回a和b的中点。</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using UnityEngine;public class Example : MonoBehaviour{    // animate the game object from -1 to +1 and back    public float minimum = -1.0F;    public float maximum =  1.0F;    // starting value for the Lerp    static float t = 0.0f;    void Update()    {        // animate the position of the game object...        transform.position = new Vector3(Mathf.Lerp(minimum, maximum, t), 0, 0);        // .. and increase the t interpolater        t += 0.5f * Time.deltaTime;        // now check if the interpolator has reached 1.0        // and swap maximum and minimum so game object moves        // in the opposite direction.        if (t &gt; 1.0f)        {            float temp = maximum;            maximum = minimum;            minimum = temp;            t = 0.0f;        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Mathf-LerpAngle"><a href="#Mathf-LerpAngle" class="headerlink" title="Mathf.LerpAngle"></a>Mathf.LerpAngle</h4><p>用法和Lerp相同，确保了在360度时值的正确插入</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using UnityEngine;public class Example:MonoBehaviour{float minAngle=0.0f;float maxAngle=90.0f;void Update(){float angle=Mathf.LerpAngle(minAngle,maxAngle,Time.time);transform.eulerAngles=new Vector3(0,angle,0);}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Mathf-LerpUnclamped"><a href="#Mathf-LerpUnclamped" class="headerlink" title="Mathf.LerpUnclamped"></a>Mathf.LerpUnclamped</h4><p>在 a 与 b 之间按照 t 进行线性插值，t 没有限制。</p><p>参数t不受限制，支持基于a和b的值。如果t小于0或大于1，则LerpUnclamped生成 a 到 b 范围之外的返回值。</p><p>假设参数a=0.33f，并且b=1.5f，如果插值器t=-0.25f，则返回值为0.0375f</p><h4 id="Mathf-LinearToGammSpace"><a href="#Mathf-LinearToGammSpace" class="headerlink" title="Mathf.LinearToGammSpace"></a>Mathf.LinearToGammSpace</h4><p>将给定值从线性转换为伽马（sRGB）颜色空间</p><h4 id="Mathf-Log"><a href="#Mathf-Log" class="headerlink" title="Mathf.Log"></a>Mathf.Log</h4><p>返回指定的数字已制定的底数为底的对数</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using UnityEngine;public class ScriptExample:MonoBehaviour{void Start(){// logarithm of 6 in base 2// prints 2.584963Debug.Log(Mathf.Log(6,2));}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>返回指定的数字的自然（以e为底）对数</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using UnityEngine;public class ScriptExample:MonoBehaviour{void Start(){// natural logarithm of 100// prints 4.60517Debug.Log(Mathf.Log(100));}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Mathf-Log10"><a href="#Mathf-Log10" class="headerlink" title="Mathf.Log10"></a>Mathf.Log10</h4><p>返回指定的数字的以10为底的对数</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using UnityEngine;public class Example:MonoBehaviour{void Start(){// logarithm of 100 in base 10// Prints 2print(Mathf.Log10(100));}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Mathf-Max"><a href="#Mathf-Max" class="headerlink" title="Mathf.Max"></a>Mathf.Max</h4><p>返回两个或更多值中的最大值</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using UnityEngine;public class ScriptExample:MonoBehaviour{void Start(){// prints 2.4Debug.Log(Mathf.Max(1.2f,2.4f));}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Mathf-Min"><a href="#Mathf-Min" class="headerlink" title="Mathf.Min"></a>Mathf.Min</h4><p>返回两个或更多值中的最小值</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using UnityEngine;public class ScriptExample:MonoBehaviour{void Start(){// prints 1.2Debug.Log(Mathf.Min(1.2f,2.4f));}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Mathf-MobeTowards"><a href="#Mathf-MobeTowards" class="headerlink" title="Mathf.MobeTowards"></a>Mathf.MobeTowards</h4><p>该函数包括三个参数分别是current（当前值）、target（要向其靠近的值）、maxDelta（对值应用的最大变化）</p><p>用于将值current向target靠近，在本质上与Mathf.Lerp相同，但是该函数确保速度不超过maxDelta。在maxDelta为负数的时候将值推离target</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using UnityEngine;public class Example:Monobehaviour{float currStrength;float maxStrength;float recoveryRate;void Update(){currStrength=Mathf.MoveTowards(currStrength,maxStrength,recoveryRate*Time.dalteTime);}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Mathf-MoveTowardsAngle"><a href="#Mathf-MoveTowardsAngle" class="headerlink" title="Mathf.MoveTowardsAngle"></a>Mathf.MoveTowardsAngle</h4><p>用法与MoveTowards相同，但是在值环绕360度时确保值能正确插入。但是在该函数下负值的maxDelta不受支持，若要将current推离目标角度，应该改为向该角度加上180</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using UnityEngine;public class Example : MonoBehaviour{    float target = 270.0f;    float speed = 45.0f;    void Update()    {        float angle = Mathf.MoveTowardsAngle(transform.eulerAngles.y, target, speed * Time.deltaTime);        transform.eulerAngles = new Vector3(0, angle, 0);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Mathf-NextPowerOfTwo"><a href="#Mathf-NextPowerOfTwo" class="headerlink" title="Mathf.NextPowerOfTwo"></a>Mathf.NextPowerOfTwo</h4><p>返回大于或者等于参数的下一个2的幂</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using UnityEnginepublic class ExampleClass:MonoBehaviour{void Start(){        //Prints 8 to the console        Debug.Log(Mathf.NextPowerOfTwo(7));        //Prints 256 to the console        Debug.Log(Mathf.NextPowerOfTwo(139));        //Prints 256 to the console        Debug.Log(Mathf.NextPowerOfTwo(256));}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Mathf-PerlinNoise"><a href="#Mathf-PerlinNoise" class="headerlink" title="Mathf.PerlinNoise"></a>Mathf.PerlinNoise</h4><p>该函数会返回一个float介于0.0和1.0之间的值，作用是产生2D柏林噪声</p><blockquote><p>柏林噪声是在 2D 平面上生成的浮点值的伪随机图案（虽然 该方法普及到三维或更高维，不过未在 Unity 中实现）。 该噪声不包含每个点处的完全随机值，而是由 “波”组成，其值在图案中逐渐增大和减小。该噪声可以 用作纹理特效的基础，以及用于动画、生成地形高度贴图 和许多其他内容。</p><p>可以通过传递相应的 X 和 Y 坐标，对平面中的任何点进行采样。 相同坐标始终返回相同采样值，但是平面本质上无穷大， 因此可通过选择随机区域进行采样以便避免重复。</p></blockquote><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using UnityEngine;using System.Collections;// Create a texture and fill it with Perlin noise.// Try varying the xOrg, yOrg and scale values in the inspector// while in Play mode to see the effect they have on the noise.public class ExampleScript : MonoBehaviour{    // Width and height of the texture in pixels.    public int pixWidth;    public int pixHeight;    // The origin of the sampled area in the plane.    public float xOrg;    public float yOrg;    // The number of cycles of the basic noise pattern that are repeated    // over the width and height of the texture.    public float scale = 1.0F;    private Texture2D noiseTex;    private Color[] pix;    private Renderer rend;    void Start()    {        rend = GetComponent&lt;Renderer&gt;();        // Set up the texture and a Color array to hold pixels during processing.        noiseTex = new Texture2D(pixWidth, pixHeight);        pix = new Color[noiseTex.width * noiseTex.height];        rend.material.mainTexture = noiseTex;    }    void CalcNoise()    {        // For each pixel in the texture...        float y = 0.0F;        while (y &lt; noiseTex.height)        {            float x = 0.0F;            while (x &lt; noiseTex.width)            {                float xCoord = xOrg + x / noiseTex.width * scale;                float yCoord = yOrg + y / noiseTex.height * scale;                float sample = Mathf.PerlinNoise(xCoord, yCoord);                pix[(int)y * noiseTex.width + (int)x] = new Color(sample, sample, sample);                x++;            }            y++;        }        // Copy the pixel data to the texture and load it into the GPU.        noiseTex.SetPixels(pix);        noiseTex.Apply();    }    void Update()    {        CalcNoise();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>虽然噪声平面是二维的，但是可方便地通过图案 仅使用单条一维线（例如用于动画特效）。</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using UnityEngine;public class Example : MonoBehaviour{    // "Bobbing" animation from 1D Perlin noise.    // Range over which height varies.    float heightScale = 1.0f;    // Distance covered per second along X axis of Perlin plane.    float xScale = 1.0f;    void Update()    {        float height = heightScale * Mathf.PerlinNoise(Time.time * xScale, 0.0f);        Vector3 pos = transform.position;        pos.y = height;        transform.position = pos;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Mathf-PingPong"><a href="#Mathf-PingPong" class="headerlink" title="Mathf.PingPong"></a>Mathf.PingPong</h4><p>返回一个值，该值将在0与length之间递增或者递减，该函数要求值t为自递增值，与Time.time和Time.unscaledTime相似</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using UnityEngine;public class PingPongExample:MonoBehaviour{Light myLight;void Start(){myLight=GetComponent&lt;Light&gt;();}void Update(){myLight.intensity=Mathf.PingPong(Time.time,8);}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Mathf-Pow"><a href="#Mathf-Pow" class="headerlink" title="Mathf.Pow"></a>Mathf.Pow</h4><p>返回 f 的 p 次幂</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using UnityEngine; public class Example:MonoBehaviour{void Start(){print(Mathf.Pow(6,1.8f));}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Mathf-Repeat"><a href="#Mathf-Repeat" class="headerlink" title="Mathf.Repeat"></a>Mathf.Repeat</h4><p>对值 t 进行循环，使它不会大于长度，并且不会小于0，类似于取模运算符，该函数适用于浮点数，没有负数定义行为</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using UnityEngine;public class Example:MonoBehaviour{void Update(){// Set the x position to loop between 0 and 3transform.position=new Vector3(Mathf.Repeat(Time.time,3),transform.position.y,transform.position.z);}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Mathf-Round"><a href="#Mathf-Round" class="headerlink" title="Mathf.Round"></a>Mathf.Round</h4><p>返回舍入为最近整数的 f。如果数字结尾是.5从而使他处于两个整数正中间（其中一个是偶数，另一个是奇数），则返回偶数</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using UnityEngine;using System.Collections;public class ExampleClass : MonoBehaviour{    // Use this for initialization    void Start()    {        // Prints 10        Debug.Log(Mathf.Round(10.0f));        // Prints 10        Debug.Log(Mathf.Round(10.2f));        // Prints 11        Debug.Log(Mathf.Round(10.7f));        // Prints 10        Debug.Log(Mathf.Round(10.5f));        // Prints 12        Debug.Log(Mathf.Round(11.5f));        // Prints -10        Debug.Log(Mathf.Round(-10.0f));        // Prints -10        Debug.Log(Mathf.Round(-10.2f));        // Prints -11        Debug.Log(Mathf.Round(-10.7f));        // Prints -10        Debug.Log(Mathf.Round(-10.5f));        // Prints -12        Debug.Log(Mathf.Round(-11.5f));    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Mathf-Sign"><a href="#Mathf-Sign" class="headerlink" title="Mathf.Sign"></a>Mathf.Sign</h4><p>返回 f 的符号。当f为正数或者是0是，返回值为1，当f为负数时，返回值为-1</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using UnityEngine;public class Example:MonoBehaviour{void Start(){Debug.Log(Mathf.Sign(-10));Debug.Log(Mathf.Sign(10));}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Mathf-Sin"><a href="#Mathf-Sin" class="headerlink" title="Mathf.Sin"></a>Mathf.Sin</h4><p>返回一个介于-1与+1之间的返回值</p><p>用于返回角度 f 的正弦</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using UnityEngine;using System.Collections;public class PolyDrawExample : MonoBehaviour{    public int numberOfSides;    public float polygonRadius;    public Vector2 polygonCenter;    void Update()    {        DebugDrawPolygon(polygonCenter, polygonRadius, numberOfSides);    }    // Draw a polygon in the XY plane with a specfied position, number of sides    // and radius.    void DebugDrawPolygon(Vector2 center, float radius, int numSides)    {        // The corner that is used to start the polygon (parallel to the X axis).        Vector2 startCorner = new Vector2(radius, 0) + center;        // The "previous" corner point, initialised to the starting corner.        Vector2 previousCorner = startCorner;        // For each corner after the starting corner...        for (int i = 1; i &lt; numSides; i++)        {            // Calculate the angle of the corner in radians.            float cornerAngle = 2f * Mathf.PI / (float)numSides * i;            // Get the X and Y coordinates of the corner point.            Vector2 currentCorner = new Vector2(Mathf.Cos(cornerAngle) * radius, Mathf.Sin(cornerAngle) * radius) + center;            // Draw a side of the polygon by connecting the current corner to the previous one.            Debug.DrawLine(currentCorner, previousCorner);            // Having used the current corner, it now becomes the previous corner.            previousCorner = currentCorner;        }        // Draw the final side by connecting the last corner to the starting corner.        Debug.DrawLine(startCorner, previousCorner);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Mathf-SmoothDamp"><a href="#Mathf-SmoothDamp" class="headerlink" title="Mathf.SmoothDamp"></a>Mathf.SmoothDamp</h4><p>参数表：current当前位置、target尝试达到的目标、currentVelocity当前速度，此值由函数在每次调用时修改、smoothTime达到目标所需要的近似时间。值越小，达到目标的速度越快、maxSpeed可以选择允许限制最大速度、deltaTime自上次调用此函数以来的时间（默认情况下为Time.deltaTime）</p><p>该函数实现了随时间推移将一个值逐渐改变为所需目标的过程，值通过某个类似于弹簧阻尼的函数（它从不超过目标）进行平滑。该函数可以用于平滑任何类型的值 、位置、颜色、标量</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using UnityEngine;public class Example:MonoBehaviour{// Sommth towards the height of the targetTransform target;float smoothTime=0.3f;float yVelocity=0.0f;void Update(){float newPosition=Mathf.SmoothDamp(transform.position.y,target.position.y,ref yVelocity,smoothTime);transform.position=new Vector3(transform.position.x,newPosition,transform.position.z);}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Mathf-SmoothDampAngle"><a href="#Mathf-SmoothDampAngle" class="headerlink" title="Mathf.SmoothDampAngle"></a>Mathf.SmoothDampAngle</h4><p>参数表：current当前位置、target尝试达到的目标、currentVelocity当前速度，此值由函数在每次调用时修改、smoothTime达到目标所需要的近似时间。值越小，达到目标的速度越快、maxSpeed可以选择允许限制最大速度、deltaTime自上次调用此函数以来的时间（默认情况下为Time.deltaTime）</p><p>该函数实现了随着时间推移将以度为单位给定的角度逐渐改变为所需目标角度，值通过某个类似于弹簧阻尼的函数（它不会超过目标）进行平滑。该函数可以用于平滑任何类型的值、位置、颜色、标量。最常见的用法就是用于平滑跟随摄像机</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using UnityEngine;public class Example : MonoBehaviour{    //A simple smooth follow camera,    // that follows the targets forward direction    Transform target;    float smooth = 0.3f;    float distance = 5.0f;    float yVelocity = 0.0f;    void Update()    {        // Damp angle from current y-angle towards target y-angle        float yAngle = Mathf.SmoothDampAngle(transform.eulerAngles.y, target.eulerAngles.y, ref yVelocity, smooth);        // Position at the target        Vector3 position = target.position;        // Then offset by distance behind the new angle        position += Quaternion.Euler(0, yAngle, 0) * new Vector3(0, 0, -distance);        // Apply the position        transform.position = position;        // Look at the target        transform.LookAt(target);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Mathf-SmoothStep"><a href="#Mathf-SmoothStep" class="headerlink" title="Mathf.SmoothStep"></a>Mathf.SmoothStep</h4><p>在 min 与 max 之间进行插值，在限制处进行平滑</p><p>该函数采用与 Lerp 相似的方法在 min 和 max 之间进行插值。但是，插值会从起点逐渐加速，然后朝着终点减慢。者可以用于创建表现十分自然地动画、淡化和其他过度</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using UnityEngine;public class Example:MonoBehaviour{// Minimum and maximum values for the transitionfloat minimum=10.0f;float maximum=20.0f;// Time taken for the transitionfloat duration=5.0f;void Start(){// Make a note of the time the script startedstartTime=Time.time;}void Update(){// Calculate the fraction of the total duration that has passedfloat t=(Time.time-startTime)/duration;transform.position=new Vector3(Mathf.SmoothStep(minimum,maximum,t),0,0);}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Mathf-Sqrt"><a href="#Mathf-Sqrt" class="headerlink" title="Mathf.Sqrt"></a>Mathf.Sqrt</h4><p>返回 f 的平方根</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using UnityEngine;using System.Collections;public class ExampleClass:MonoBehaviour{    // The formula made famous by Pythagoras, also used internally by    // Vector3.Distance and several other standard functions.    float HypotenuseLength(float sideALength, float sideBLength)    {        return Mathf.Sqrt(sideALength * sideALength + sideBLength * sideBLength);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Mathf-Tan"><a href="#Mathf-Tan" class="headerlink" title="Mathf.Tan"></a>Mathf.Tan</h4><p>返回角度 f 的正切（以弧度为单位）</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using UnityEngine;using System.Collections;public class ExampleClass:MonoBehaviour{void Example(){print(Mathf.Tan(0.5F));}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> Unity </tag>
            
            <tag> 游戏开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity项目作业_直升机</title>
      <link href="/2022/09/03/unity-xiang-mu-zuo-ye-zhi-sheng-ji/"/>
      <url>/2022/09/03/unity-xiang-mu-zuo-ye-zhi-sheng-ji/</url>
      
        <content type="html"><![CDATA[<h3 id="课程要求"><a href="#课程要求" class="headerlink" title="课程要求"></a>课程要求</h3><p>该项目要求制作一个可以进行飞行的直升机，具体内容包括直升机的移动以及螺旋桨的转动两个模块</p><p>其中直升机的移动模块通过 transform.position 模块进行实现，螺旋桨转动通过 transform.Rotate 模块进行实现</p><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>项目使用Unity免费素材Police Helicopter中的Helicopter模型，该模型除主要机体外还分为Main_Rotor和Tail_Rotor两个螺旋桨。</p><h3 id="模型移动"><a href="#模型移动" class="headerlink" title="模型移动"></a>模型移动</h3><p>该项目模型移动通过了transform.Translate对模型的坐标进行移动从而实现整体模型的移动，并且移动模式通过if(Input.GetKey)函数来进行键盘输入判断，若接收相应按键则产生移动反馈。</p><h5 id="具体反馈如下："><a href="#具体反馈如下：" class="headerlink" title="具体反馈如下："></a>具体反馈如下：</h5><h6 id="Space：上升、LeftShift：下降、W：向前移动、S：向后移动、A：向左平移、D：向右平移、Z：向左转向、C：向右转向"><a href="#Space：上升、LeftShift：下降、W：向前移动、S：向后移动、A：向左平移、D：向右平移、Z：向左转向、C：向右转向" class="headerlink" title="Space：上升、LeftShift：下降、W：向前移动、S：向后移动、A：向左平移、D：向右平移、Z：向左转向、C：向右转向"></a>Space：上升、LeftShift：下降、W：向前移动、S：向后移动、A：向左平移、D：向右平移、Z：向左转向、C：向右转向</h6><h5 id="具体脚本如下："><a href="#具体脚本如下：" class="headerlink" title="具体脚本如下："></a>具体脚本如下：</h5><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// Helicopter.csusing System.Collections;using System.Collections.Generic;using UnityEngine;public class Helicopter : MonoBehaviour{    public float upSpeed = 10f;    public float forwardSpeed = 10f;    public float downSpeed = 10f;    public float leftSpeed = 10f;    public float rightSpeed = 10f;    public float leftRotate = 10f;    // Start is called before the first frame update    void Start()    {            }    // Update is called once per frame    void Update()    {        if(Input.GetKey(KeyCode.Space))        {            transform.Translate(Vector3.up * upSpeed * Time.deltaTime);        }        if(Input.GetKey(KeyCode.LeftShift))        {            transform.Translate(Vector3.down * downSpeed * Time.deltaTime);        }        if(Input.GetKey(KeyCode.W))        {            transform.Translate(Vector3.forward*forwardSpeed * Time.deltaTime);        }        if(Input.GetKey(KeyCode.S))        {            transform.Translate(Vector3.back*forwardSpeed * Time.deltaTime);        }        if (Input.GetKey(KeyCode.A))        {            transform.Translate(Vector3.left * leftSpeed * Time.deltaTime);        }        if (Input.GetKey(KeyCode.D))        {            transform.Translate(Vector3.right * leftSpeed * Time.deltaTime);        }        if(Input.GetKey(KeyCode.Z))        {            transform.Rotate(Vector3.up * leftRotate * Time.deltaTime);        }        if (Input.GetKey(KeyCode.C))        {            transform.Rotate(Vector3.down * leftRotate * Time.deltaTime);        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该项目的摄像机进行了自动跟随处理，具体脚本处理来源网络资源</p><h5 id="具体脚本如下：-1"><a href="#具体脚本如下：-1" class="headerlink" title="具体脚本如下："></a>具体脚本如下：</h5><pre class="line-numbers language-C#" data-language="C#"><code class="language-C#">// Camera_Demo.csusing System.Collections;using System.Collections.Generic;using UnityEngine;public class Camera_Demo : MonoBehaviour{    public Transform target;    public float distanceUp = 15f;    public float distanceAway = 10f;    public float smooth = 2f;    public float camDepthSmooth = 5f;    // Start is called before the first frame update    void Start()    {            }    // Update is called once per frame    void Update()    {        // 鼠标轴控制相机的远近        if ((Input.mouseScrollDelta.y &lt; 0 &amp;&amp; Camera.main.fieldOfView &gt;= 3) || Input.mouseScrollDelta.y &gt; 0 &amp;&amp; Camera.main.fieldOfView &lt;= 80)        {            Camera.main.fieldOfView += Input.mouseScrollDelta.y * camDepthSmooth * Time.deltaTime;        }    }    void LateUpdate()    {        //相机的位置        Vector3 disPos = target.position + Vector3.up * distanceUp - target.forward * distanceAway; transform.position = Vector3.Lerp(transform.position, disPos, Time.deltaTime * smooth);        //相机的角度        transform.LookAt(target.position);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>项目直升机双螺旋桨的旋转过程通过建立直升机螺旋桨对象propellerObj，通过transform.Rotate函数进行旋转。</p><h5 id="具体脚本代码如下："><a href="#具体脚本代码如下：" class="headerlink" title="具体脚本代码如下："></a>具体脚本代码如下：</h5><pre class="line-numbers language-C#" data-language="C#"><code class="language-C#">// Rotor_Main.cs// Rotor_Tail.csusing System.Collections;using System.Collections.Generic;using UnityEngine;public class Rotor_Main : MonoBehaviour{    /// &lt;summary&gt;    /// 直升机螺旋桨对象    /// &lt;/summary&gt;    public GameObject propellerObj;    // Start is called before the first frame update    void Start()    {            }    // Update is called once per frame    void Update()    {        propellerObj.transform.Rotate(Vector3.up * 2000 * Time.deltaTime);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="以下是项目具体运行以及部分操作演示"><a href="#以下是项目具体运行以及部分操作演示" class="headerlink" title="以下是项目具体运行以及部分操作演示"></a>以下是项目具体运行以及部分操作演示</h5><p><video src="E:\GitHubMatery\source\_posts\HelicopterDemo.mp4"></video></p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> Unity </tag>
            
            <tag> 游戏开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity游戏开发笔记</title>
      <link href="/2022/09/03/unity-you-xi-kai-fa-bi-ji/"/>
      <url>/2022/09/03/unity-you-xi-kai-fa-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="模型移动"><a href="#模型移动" class="headerlink" title="模型移动"></a>模型移动</h2><p>通过 transform.Translate 函数来对模型进行移动操作</p><p>实现如下</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">transform.Translate(Vector3.up*upSpeed*Time.deltaTime);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中在Vector3中对应的坐标可以通过以下操作对应</p><ul><li>back 对应 Vector3(0,0,-1)</li><li>down 对应 Vector3(0,-1,0)</li><li>forward 对应 Vector3(0,0,1)</li><li>left 对应 Vector3(-1,0,0)</li><li>one 对应 Vector3(1,1,1)</li><li>right 对应 Vector3(0,1,0)</li><li>up 对应 Vector3(0,1,0)</li><li>zero 对应 Vector3(0,0,0)</li></ul><p>通过 transform.Rotate 函数来对模型进行旋转操作</p><p>实现如下</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">propellerObj.transform.Rotate(Vector3.up*2000*Time.deltaTime)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="键盘接受与反馈"><a href="#键盘接受与反馈" class="headerlink" title="键盘接受与反馈"></a>键盘接受与反馈</h2><p>通过 Input.GetKey 来持续接受（按住）时返回true</p><p>通过 Input.GetKeyDown 来接受用户按下的那一帧返回true</p><p>通过 Input.GetKeyUp 来接受用户释放的那一帧返回true</p><p>实现如下</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">Input.GetKey(keyCode.space)Input.GetKeyDown(KeyCode.space)Input.GetKeyUp(KeyCode.space)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="读取上一帧所需要的时间实现移动"><a href="#读取上一帧所需要的时间实现移动" class="headerlink" title="读取上一帧所需要的时间实现移动"></a>读取上一帧所需要的时间实现移动</h2><p>通过 Time.deltaTime 函数来读取上一帧所用的时间（以秒为单位）</p><p>实现如下</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">propellerObj.transform.Rotate(Vector3.up*2000*Time.deltaTime)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> Unity </tag>
            
            <tag> 游戏开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一个全新的博客</title>
      <link href="/2022/09/03/yi-ge-quan-xin-de-bo-ke/"/>
      <url>/2022/09/03/yi-ge-quan-xin-de-bo-ke/</url>
      
        <content type="html"><![CDATA[<h1 id="白猫wHCat的博客"><a href="#白猫wHCat的博客" class="headerlink" title="白猫wHCat的博客"></a>白猫wHCat的博客</h1><h5 id="该博客建立于2022年9月1日，在后期将常态化更新学习编程开发技巧以及个人的学习记录。"><a href="#该博客建立于2022年9月1日，在后期将常态化更新学习编程开发技巧以及个人的学习记录。" class="headerlink" title="该博客建立于2022年9月1日，在后期将常态化更新学习编程开发技巧以及个人的学习记录。"></a>该博客建立于2022年9月1日，在后期将常态化更新学习编程开发技巧以及个人的学习记录。</h5><p>在该博客中，将主要更新C/C++开发，数据结构与算法，面经，考研，C#开发，游戏开发等多种软件工程有关文章，文章仅用于个人开发学习心得记录。</p>]]></content>
      
      
      <categories>
          
          <category> Diary </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
