<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C++日期与时间</title>
      <link href="/2022/11/26/c-ri-qi-yu-shi-jian/"/>
      <url>/2022/11/26/c-ri-qi-yu-shi-jian/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++引用整理</title>
      <link href="/2022/11/26/c-yin-yong-zheng-li/"/>
      <url>/2022/11/26/c-yin-yong-zheng-li/</url>
      
        <content type="html"><![CDATA[<h5 id="C-引用整理"><a href="#C-引用整理" class="headerlink" title="C++引用整理"></a>C++引用整理</h5><p>在C++中引用变量是一个别名，也就是说，他是某个已存在变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或引用变量来指向变量。</p><h6 id="C-引用与指针的关系"><a href="#C-引用与指针的关系" class="headerlink" title="C++引用与指针的关系"></a>C++引用与指针的关系</h6><p>引用与指针之间有三个主要的不同</p><ul><li>不存在空引用。引用必须连接到一块合法的内存。</li><li>一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象</li><li>引用必须在创建时被初始化。指针可以在任何时间被初始化</li></ul><h6 id="C-中创建引用"><a href="#C-中创建引用" class="headerlink" title="C++中创建引用"></a>C++中创建引用</h6><p>变量名称是变量附属在内存位置中的标签，用户可以把引用当作是变量附属在内存位置中的第二个标签。所以，用户可以通过原始变量名称或引用来访问变量的内容，例如：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">17</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>用户可以为i声明引用变量，如下所示：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token operator">&amp;</span>r<span class="token operator">=</span>i<span class="token punctuation">;</span><span class="token keyword">double</span> <span class="token operator">&amp;</span>s <span class="token operator">=</span> d<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在这些声明中，&amp;叫做引用。所以第一个声明可以被称为”r是一个初始化为i的整形引用“，第二个声明可以读作”s是一个初始化为d的double型引用“。下面的实例使用了int和double引用：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">// 声明简单的变量</span><span class="token keyword">int</span> i<span class="token punctuation">;</span><span class="token keyword">double</span> d<span class="token punctuation">;</span><span class="token comment">// 声明引用变量</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>r <span class="token operator">=</span> i<span class="token punctuation">;</span><span class="token keyword">double</span> <span class="token operator">&amp;</span>s <span class="token operator">=</span> d<span class="token punctuation">;</span>i <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Value of i:"</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Value of i reference:"</span> <span class="token operator">&lt;&lt;</span> r <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>d <span class="token operator">=</span> <span class="token number">11.7</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Value of d:"</span> <span class="token operator">&lt;&lt;</span> d <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Value of d reference:"</span> <span class="token operator">&lt;&lt;</span> s <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码执行后产生如下结果：</p><blockquote><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Value of i <span class="token operator">:</span> <span class="token number">5</span>Value of i reference <span class="token operator">:</span> <span class="token number">5</span>Value of d <span class="token operator">:</span> <span class="token number">11.7</span>Value of d reference <span class="token operator">:</span> <span class="token number">11.7</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></blockquote><p>引用通常用于函数参数列表和函数返回值。</p><h6 id="C-把引用作为参数"><a href="#C-把引用作为参数" class="headerlink" title="C++把引用作为参数"></a>C++把引用作为参数</h6><p>利用下述实例使用了医用来实现引用调用函数。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token comment">// 函数声明</span><span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">&amp;</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">// 局部变量声明</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"交换前，a的值:"</span> <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"交换前，b的值:"</span> <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment">// 调用函数来交换值</span><span class="token function">swap</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"交换后，a的值:"</span> <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"交换后，b的值:"</span> <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 函数定义</span><span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">&amp;</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> y<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> temp<span class="token punctuation">;</span>temp <span class="token operator">=</span> x<span class="token punctuation">;</span><span class="token comment">// 保存地址x的值</span>x <span class="token operator">=</span> y<span class="token punctuation">;</span><span class="token comment">// 把y赋值给x</span>y <span class="token operator">=</span> temp<span class="token punctuation">;</span><span class="token comment">// 把x赋值给y</span><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码在编译后得到的执行结果如下：</p><blockquote><p>交换前，a的值:100</p><p>交换前，b的值:200</p><p>交换后，a的值:200</p><p>交换后，b的值:100</p></blockquote><h6 id="C-把引用作为返回值"><a href="#C-把引用作为返回值" class="headerlink" title="C++把引用作为返回值"></a>C++把引用作为返回值</h6><p>通过使用引用来代替指针，会使C++程序更容易阅读和维护。C++函数可以返回一个引用，方式与返回一个指针类似。</p><p>当函数返回一个引用时，则返回一个指向返回值的隐式指针。这样函数就可以放在赋值语句的左边，示例如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">double</span> vals<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">10.1</span><span class="token punctuation">,</span> <span class="token number">12.6</span><span class="token punctuation">,</span> <span class="token number">33.1</span><span class="token punctuation">,</span> <span class="token number">24.1</span><span class="token punctuation">,</span> <span class="token number">50.0</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">double</span><span class="token operator">&amp;</span> <span class="token function">setValues</span><span class="token punctuation">(</span> <span class="token keyword">int</span> i <span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> vals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// 返回第i个元素的引用</span><span class="token punctuation">}</span><span class="token comment">// 要调用上面定义函数的主函数</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"改变前的值"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"vals["</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">"] ="</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> vals<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">setValues</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">20.23</span><span class="token punctuation">;</span><span class="token comment">// 改变第2个元素</span><span class="token function">setValues</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">70.8</span><span class="token punctuation">;</span><span class="token comment">// 改变第4个元素</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"改变后的值"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"vals["</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">"] ="</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> vals<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码调用执行后结果如下：</p><blockquote><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">改变前的值vals<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">10.1</span>vals<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">12.6</span>vals<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">33.1</span>vals<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">24.1</span>vals<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">50</span>改变后的值vals<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">10.1</span>vals<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">20.23</span>vals<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">33.1</span>vals<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">70.8</span>vals<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">50</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><p>当返回一个引用时，要注意被引用的对象不能超出作用域。所以返回一个对局部变量的引用是不合法的，但是可以返回一个静态变量的引用</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span><span class="token operator">&amp;</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> q<span class="token punctuation">;</span><span class="token comment">//! return q;// 在编译时发生错误</span><span class="token keyword">static</span> <span class="token keyword">int</span> x<span class="token punctuation">;</span><span class="token keyword">return</span> x<span class="token punctuation">;</span><span class="token comment">// 安全，x在函数作用域外依然是有效的</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++存储类整理</title>
      <link href="/2022/11/26/c-cun-chu-lei-zheng-li/"/>
      <url>/2022/11/26/c-cun-chu-lei-zheng-li/</url>
      
        <content type="html"><![CDATA[<h3 id="C-存储类介绍"><a href="#C-存储类介绍" class="headerlink" title="C++存储类介绍"></a>C++存储类介绍</h3><p>存储类定义C++程序中变量/函数的范围（可见性）和生命周期。这些说明符放置在他们所修饰的类型之前，其中C++可用的存储类包括</p><ul><li>auto</li><li>register</li><li>static</li><li>extern</li><li>mutable</li><li>thread_local(C++11)</li></ul><blockquote><p>其中auto关键字已经不再是C++存储类的说明符，并且register关键字已经被弃用</p></blockquote><h5 id="auto存储类"><a href="#auto存储类" class="headerlink" title="auto存储类"></a>auto存储类</h5><p>从C++11之后，auto关键字主要用于两种情况：声明变量时根据初始化表达式自动推断该变量的类型、声明函数时函数返回值的占位符</p><p>C++98标准中的auto关键字用于自动变量的生命，但是使用量少，所以在C++11中已经删除了这一用法</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> f<span class="token operator">=</span><span class="token number">3.14</span><span class="token punctuation">;</span><span class="token comment">//double</span><span class="token keyword">auto</span> <span class="token function">s</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//const char*</span><span class="token keyword">auto</span> z<span class="token operator">=</span><span class="token keyword">new</span> <span class="token keyword">auto</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//int</span><span class="token keyword">auto</span> x1 <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">,</span> x2 <span class="token operator">=</span> <span class="token number">5.0</span><span class="token punctuation">,</span> x3 <span class="token operator">=</span> <span class="token char">'r'</span><span class="token punctuation">;</span><span class="token comment">//错误，必须是初始化为同一类型</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="register存储类"><a href="#register存储类" class="headerlink" title="register存储类"></a>register存储类</h5><p>register存储类用于定义存储在寄存器中而不是RAM中的局部变量，这意味着遍历啊那个的最大尺寸等于寄存器的大小（通常是一个词），并且不能对它引用一元运算符‘&amp;’（因为该存储类没有内存位置）</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token punctuation">{</span><span class="token keyword">register</span> <span class="token keyword">int</span> miles<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>寄存器只用于需要快速访问的变量，比如计数器。并且在定义’register’并不意味着变量将被存储在寄存器中，它意味着变量可能存储在寄存器中，这取决于硬件和实现的限制。</p><h5 id="static存储类"><a href="#static存储类" class="headerlink" title="static存储类"></a>static存储类</h5><p>static存储来知识编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用static修饰局部变量可以在函数调用之间保持局部变量的值</p><p>static修饰符也可以应用于全局变量。当static修饰全局变量时，会使变量的作用域限制在声明他的文件内</p><p>在C++中，当static用在类数据成员上时，会导致仅有一个该成员的副本被类的所有对象共享</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span><span class="token comment">// 函数声明</span><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token keyword">static</span> <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token comment">// 全局变量</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">while</span><span class="token punctuation">(</span>count<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 函数定义</span><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">static</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span><span class="token comment">// 局部静态变量</span>i<span class="token operator">++</span><span class="token punctuation">;</span>std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"变量 i 为"</span> <span class="token operator">&lt;&lt;</span> i<span class="token punctuation">;</span>std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">" ,变量 count 为"</span> <span class="token operator">&lt;&lt;</span> count <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>调用后运行结果</p><blockquote><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">变量 i 为 <span class="token number">6</span><span class="token punctuation">,</span> 变量 count 为 <span class="token number">9</span>变量 i 为 <span class="token number">7</span><span class="token punctuation">,</span> 变量 count 为 <span class="token number">8</span>变量 i 为 <span class="token number">8</span><span class="token punctuation">,</span> 变量 count 为 <span class="token number">7</span>变量 i 为 <span class="token number">9</span><span class="token punctuation">,</span> 变量 count 为 <span class="token number">6</span>变量 i 为 <span class="token number">10</span><span class="token punctuation">,</span> 变量 count 为 <span class="token number">5</span>变量 i 为 <span class="token number">11</span><span class="token punctuation">,</span> 变量 count 为 <span class="token number">4</span>变量 i 为 <span class="token number">12</span><span class="token punctuation">,</span> 变量 count 为 <span class="token number">3</span>变量 i 为 <span class="token number">13</span><span class="token punctuation">,</span> 变量 count 为 <span class="token number">2</span>变量 i 为 <span class="token number">14</span><span class="token punctuation">,</span> 变量 count 为 <span class="token number">1</span>变量 i 为 <span class="token number">15</span><span class="token punctuation">,</span> 变量 count 为 <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><h5 id="extern存储类"><a href="#extern存储类" class="headerlink" title="extern存储类"></a>extern存储类</h5><p>extern存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当您使用’extern’时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。</p><p>当有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用extern来得到一定义的变量或函数的引用。可以这么理解，extern是用来在另一个文件中声明一个全局变量或函数</p><p>extern修饰符通常用于当有两个或多个文件共享相同的全局变量或函数的时候</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// main.cpp</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">int</span> count<span class="token punctuation">;</span><span class="token keyword">extern</span> <span class="token keyword">void</span> <span class="token function">write_extern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>count <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span><span class="token function">write_extern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// support.cpp</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">extern</span> <span class="token keyword">int</span> count<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">write_extern</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Count is"</span> <span class="token operator">&lt;&lt;</span> count <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在第二个文件中extern的关键字用于声明已经在第一个文件中main.cpp中定义的count，在编译后会发现生成为</p><blockquote><p>Count is 5</p></blockquote><h5 id="mutable存储类"><a href="#mutable存储类" class="headerlink" title="mutable存储类"></a>mutable存储类</h5><p>mutable说明符仅适用于类的对象，它允许对象的成员替换常量。由此可知mutable成员可以通过const成员函数修改</p><h5 id="thread-local存储类"><a href="#thread-local存储类" class="headerlink" title="thread_local存储类"></a>thread_local存储类</h5><p>thread_local说明符声明的变量仅可在它上创建的线程上访问，变量在创建线程的时候创建，在销毁线程是销毁。</p><p>每个线程都有自己的变量副本</p><p>thread_local说明符可以和static或extern合并</p><p>可以将thread_local仅应用于数据声明和定义，thread_local不能用于函数声明或定义</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">thread_local</span> <span class="token keyword">int</span> x<span class="token punctuation">;</span><span class="token comment">// 命名空间下的全局变量</span><span class="token keyword">class</span> <span class="token class-name">X</span><span class="token punctuation">{</span><span class="token keyword">static</span> <span class="token keyword">thread_local</span> std<span class="token double-colon punctuation">::</span>string s<span class="token punctuation">;</span><span class="token comment">// 类的static成员变量</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">thread_local</span> std<span class="token double-colon punctuation">::</span>string X<span class="token double-colon punctuation">::</span>s<span class="token punctuation">;</span><span class="token comment">// X::s是需要定义的</span><span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">thread_local</span> std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> v<span class="token punctuation">;</span><span class="token comment">//本地变量</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="Lambda函数与表达式"><a href="#Lambda函数与表达式" class="headerlink" title="Lambda函数与表达式"></a>Lambda函数与表达式</h5><p>Lambda被称为匿名函数，其中Lambda表达式把函数看作对象，其表达式可以像对象一样使用，如可以给它们赋值变量和作为参数传递，还可以像函数一样对其求值。</p><p>Lambda表达式本质上与函数声明非常类似。Lambda表达式的具体形式如下</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token punctuation">[</span>capture<span class="token punctuation">]</span><span class="token punctuation">(</span>parameters<span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token keyword">return</span><span class="token operator">-</span>type<span class="token punctuation">{</span>body<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> x <span class="token operator">&lt;</span> y<span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果没有返回值可以表示为</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token punctuation">[</span>capture<span class="token punctuation">]</span><span class="token punctuation">(</span>parameters<span class="token punctuation">)</span><span class="token punctuation">{</span>body<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>例如</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token operator">++</span>global_x<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在一个更复杂的例子中，返回类型可以被明确的制定如下</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token keyword">int</span><span class="token punctuation">{</span><span class="token keyword">int</span> z <span class="token operator">=</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span> <span class="token keyword">return</span> z <span class="token operator">+</span> x<span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++指针整理</title>
      <link href="/2022/11/26/c-zhi-zhen-zheng-li/"/>
      <url>/2022/11/26/c-zhi-zhen-zheng-li/</url>
      
        <content type="html"><![CDATA[<h3 id="C-指针介绍"><a href="#C-指针介绍" class="headerlink" title="C++指针介绍"></a>C++指针介绍</h3><p>通过C++的指针可以大幅度的简化C++编程任务的执行，并且可以进行动态内存分配</p><p>在C++中每一个变量都有一个内存位置，每一个内存位置都定义了可使用连字号(&amp;)运算符访问的地址，他表示了在内存中的一个地址</p><p>如下实例，可以输出定义的变量地址</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> var1<span class="token punctuation">;</span><span class="token keyword">char</span> var2<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"var1 变量的地址:"</span><span class="token punctuation">;</span>cout<span class="token operator">&lt;&lt;</span> <span class="token operator">&amp;</span>var1 <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"var2 变量的地址:"</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">&amp;</span>var2 <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行后的结果为</p><blockquote><p>var1 变量的地址:0xbfebd5c0</p><p>var2 变量的地址:0xbfebd5b6</p></blockquote><h5 id="指针的定义"><a href="#指针的定义" class="headerlink" title="指针的定义"></a>指针的定义</h5><p>指针是一个变量，它的值是另一个变量的地址，即为内存位置的直接地址。</p><p>就像是其他的变量和常量一样，用户在使用指针存储其他变量地址之前，应该对其进行声明，指针变量的声明方式的一般形式是：</p><blockquote><p>type *var-name;</p></blockquote><p>在这其中，type是指针的基类型，它必须是一个有效的C++数据类型，var-name是指针变量的名称。用来声明指针的星号*与乘法中使用的星号是相同的。但是在这个语句中，星号是用来指定一个变量是指针。</p><p>下面是指针的有效声明</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token operator">*</span>ip<span class="token punctuation">;</span><span class="token comment">// 一个整形的指针</span><span class="token keyword">double</span> <span class="token operator">*</span>dp<span class="token punctuation">;</span><span class="token comment">// 一个double类型的指针</span><span class="token keyword">float</span> <span class="token operator">*</span>fp<span class="token punctuation">;</span><span class="token comment">//一个浮点型的指针</span><span class="token keyword">char</span> <span class="token operator">*</span>ch<span class="token punctuation">;</span><span class="token comment">//一个字符型的指针</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="在C-中使用指针的实例"><a href="#在C-中使用指针的实例" class="headerlink" title="在C++中使用指针的实例"></a>在C++中使用指针的实例</h5><p>在使用指针的过程中会存在以下的操作：定义一个指针变量、将变量地址赋值给指针、访问指针变量中可用地址的值，以上这些都是通过一元运算符*来返回位于操作数所指定地址的变量的值</p><p>其操作实例：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> var <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span><span class="token comment">// 实际变量的声明</span><span class="token keyword">int</span> <span class="token operator">*</span>ip<span class="token punctuation">;</span><span class="token comment">// 指针变量的声明</span>ip <span class="token operator">=</span> <span class="token operator">&amp;</span>var<span class="token punctuation">;</span><span class="token comment">// 在指针变量中存储 var 的地址</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Value of var variable:"</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> var <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment">// 输出在指针变量中存储的地址</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Address stored in ip varivable:"</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>ip <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行后的结果为</p><blockquote><p>Value of var variable:20</p><p>Address stored in ip variable:0xbfc601ac</p><p>Value of *ip variable:20</p></blockquote><h5 id="C-中的Null指针"><a href="#C-中的Null指针" class="headerlink" title="C++中的Null指针"></a>C++中的Null指针</h5><p>在变量声明的时候，如果没有确切的地址可以赋值，为指针变量夫一个NULL值是一个较为良好的编程习惯。赋为NULL的指针被称为空指针</p><p>NULL指针是一个定义在标准库中的值为0的常量</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> <span class="token operator">*</span>ptr <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ptr的值是:"</span> <span class="token operator">&lt;&lt;</span> ptr<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行后的结果为</p><blockquote><p>ptr的值是0</p></blockquote><p>在大多数的操作系统上，成勋不允许访问地址为0的内存，因为该内存是操作系统所保留的，然而内存地址0有特别的重要意义，它表明该指针不指向一个可访问的内存地址。按照惯例，如果指针包含空值（0），则假定它不指向任何东西</p><p>如果要检查一个空指针，可以通过以下的if语句</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">if</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token comment">// 如果ptr非空，则完成</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>ptr<span class="token punctuation">)</span><span class="token comment">// 如果ptr为空，则完成</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>因此，如果所有未使用的指针都被赋予空值，同时避免使用空指针，就可以防止误用一个未初始化的指针。很多时候，未初始化的变量存有一些垃圾之，导致程序难以调试。</p><h5 id="C-指针的算术运算"><a href="#C-指针的算术运算" class="headerlink" title="C++指针的算术运算"></a>C++指针的算术运算</h5><p>指针是一个用数值表示的地址。所以用户可以通过指针执行算术运算。可以对指针进行四种算数运算：++、–、+、-</p><p>假设ptr是一个指向地址1000的整形指针，是一个32位的整数，让我们对该指针执行下列的算术运算：</p><blockquote><p>ptr++</p></blockquote><p>在执行完上述操作后，ptr将指向位置1004，因为ptr没增加一次，它都将指向下一个整数的位置，即当前位置往后移动4个字节。这个运算会在不影响内存位置中实际值的情况下，移动指针到下一个内存位置。如果ptr指向一个地址为1000的字符，上面的运算会导致指针指向位置1001，因为下一个 字符位置是在1001。</p><h6 id="递增一个指针"><a href="#递增一个指针" class="headerlink" title="递增一个指针"></a>递增一个指针</h6><p>在程序中应习惯用指针代替数组，因为变量指针可以递增，而数组不能递增，因为数组是一个常量指针。下面的案例是使用了递增变量指针，以便顺序访问数组中的每一个元素：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostram&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> MAX <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> var<span class="token punctuation">[</span>MAX<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">*</span>ptr<span class="token punctuation">;</span><span class="token comment">// 指针中的数组地址</span>ptr <span class="token operator">=</span> var<span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> MAX<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Address of var["</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">"] ="</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> ptr <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Value of var["</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">"] ="</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>ptr <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token comment">// 移动到下一个位置</span>ptr<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行后的结果：</p><blockquote><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Address of var<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0xbfa088b0</span>Value of var<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">10</span>Address of var<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0xbfa088b4</span>Value of var<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">100</span>Address of var<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0xbfa088b8</span>Value of var<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">200</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><h6 id="递减一个指针"><a href="#递减一个指针" class="headerlink" title="递减一个指针"></a>递减一个指针</h6><p>同递增指针一样对指针进行递减运算，即把值减去其他数据类型的字节数：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostram&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> MAX <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> var<span class="token punctuation">[</span>MAX<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">*</span>ptr<span class="token punctuation">;</span><span class="token comment">// 指针中最后一个元素的地址</span>ptr <span class="token operator">=</span> <span class="token operator">&amp;</span>var<span class="token punctuation">[</span>MAX <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> MAX<span class="token punctuation">;</span> i <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Address of var["</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">"] ="</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> ptr <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Value of var["</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span><span class="token string">"] ="</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>ptr <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment">// 移动到下一个位置</span>ptr<span class="token operator">--</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码执行后的结果为</p><blockquote><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Address of var<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0xbfdb70f8</span>Value of var<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">200</span>Address of var<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0xbfdb70f4</span>Value of var<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">100</span>Address of var<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0xbfdb70f0</span>Value of var<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">10</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><h6 id="指针的比较"><a href="#指针的比较" class="headerlink" title="指针的比较"></a>指针的比较</h6><p>指针可以用关系运算符进行比较，如==,&lt;和&gt;。如果p1和p2指向两个相关的变量，比如同一个数组中的不同元素，则可以对p1和p2进行大小比较。</p><p>下面的程序修改了上面的实例，只要变量指针所指向的地址小于或等于数组的最后一个元素的地址&amp; var[MAX - 1]，则把变量指针进行递增：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> MAX <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> var<span class="token punctuation">[</span>MAX<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">*</span>ptr<span class="token punctuation">;</span><span class="token comment">// 指针中第一个元素的地址</span>ptr <span class="token operator">=</span> var<span class="token punctuation">;</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span> ptr <span class="token operator">&lt;=</span> <span class="token operator">&amp;</span>var<span class="token punctuation">[</span>MAX <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Address of var["</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span><span class="token string">"] ="</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> ptr <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Value of var["</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span><span class="token string">"] ="</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>ptr <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment">// 指向上一个位置</span>ptr<span class="token operator">++</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码执行后结果为：</p><blockquote><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Address of var<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0xbfce42d0</span>Value of var<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">10</span>Address of var<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0xbfce42d4</span>Value of var<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">100</span>Address of var<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0xbfce42d8</span>Value of var<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">200</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><h6 id="C-中指针与数组的关系"><a href="#C-中指针与数组的关系" class="headerlink" title="C++中指针与数组的关系"></a>C++中指针与数组的关系</h6><p>指针与数组的关系是紧密相关的。在实际使用的情况下，很多时候指针与数组是可以相互转换的。例如一个指向数组开头的指针，可以通过使用指针的算术运算或数组索引来访问数组。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> MAX <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> var<span class="token punctuation">[</span>MAX<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">*</span>ptr<span class="token punctuation">;</span><span class="token comment">// 指针中的数组地址</span>ptr <span class="token operator">=</span> var<span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> MAX<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"var["</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">"]的内存地址为"</span><span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span> ptr <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>                cout <span class="token operator">&lt;&lt;</span> <span class="token string">"var["</span> <span class="token operator">&lt;&lt;</span>i <span class="token operator">&lt;&lt;</span> <span class="token string">"]的值为"</span><span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>ptr <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>                <span class="token comment">// 移动到下一个位置</span>        ptr<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码执行后的结果为：</p><blockquote><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">var<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>的内存地址为 <span class="token number">0x7fff59707adc</span>var<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> 的值为 <span class="token number">10</span>var<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>的内存地址为 <span class="token number">0x7fff59707ae0</span>var<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> 的值为 <span class="token number">100</span>var<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span>的内存地址为 <span class="token number">0x7fff59707ae4</span>var<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> 的值为 <span class="token number">200</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><p>在实际使用情况中，指针和数组并不是完全相互互通的。</p><p>举例如下</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> MAX <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> var<span class="token punctuation">[</span>MAX<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> MAX<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token operator">*</span>var <span class="token operator">=</span> i<span class="token punctuation">;</span><span class="token comment">// 这是正确的语法</span>var<span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment">// 这是不正确的语法</span><span class="token punctuation">}</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>把指针运算符*引用到var上是完全可以的，但是修改var的值是非法的。这是因为var是一个指向数组开头的常量，不能作为左值。</p><p>由于一个数组名对应一个指针常量，只要不改变数组的值，仍然可以用指针形式的表达式。例如，下面是一个有效的语句，把var[2]赋值为500;</p><blockquote><p>*(var + 2) = 500;</p></blockquote><p>上面的语句是有效的，并且可以正常的进行编译，因为var未改变。</p><h5 id="C-指针数组"><a href="#C-指针数组" class="headerlink" title="C++指针数组"></a>C++指针数组</h5><p>对于指针数组的概念，首先可以通过由3个整数组成的数组：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> MAX <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> var<span class="token punctuation">[</span>MAX<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> MAX<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Value of var["</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">"] ="</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> var<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码执行后的结果：</p><blockquote><p>Value of var[0] = 10</p><p>Value of var[1] = 100</p><p>Value of var[2] = 200</p></blockquote><p>其中包括一种情况，我们想要让数组存储指针指向int或者char或者其他数据类型的指针。向下面是一个指向整数的指针数组的声明：</p><blockquote><p>int *ptr[MAX];</p></blockquote><p>在这个情况中ptr声明为一个数组，由MAX个整数指针组成。因此ptr中的每一个元素都是一个指向int值的指针。在下面的实例中，用到了三个整数，它们将存储在一个指针数组中，如下所示：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> MAX <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> var<span class="token punctuation">[</span>MAX<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">*</span>ptr<span class="token punctuation">[</span>MAX<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> MAX<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>ptr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>var<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// 赋值为整数的地址</span><span class="token punctuation">}</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> MAX<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Value of var["</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">"] ="</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>ptr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码执行的结果为：</p><blockquote><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Value of var<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">10</span>Value of var<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">100</span>Value of var<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">200</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></blockquote><p>用户也可以用一个指向字符的指针数组来存储一个字符串列表，如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> MAX <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>names<span class="token punctuation">[</span>MAX<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"Zara Ali"</span><span class="token punctuation">,</span><span class="token string">"Hina Ali"</span><span class="token punctuation">,</span><span class="token string">"Nuha Ali"</span><span class="token punctuation">,</span><span class="token string">"Sara Ali"</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> MAX<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Value of names["</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">"] ="</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> names<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码的执行结果为：</p><blockquote><p>Value of names[0] = Zara Ali</p><p>Value of names[1] = Hina Ali</p><p>Value of names[2] = Nuha Ali</p><p>Value of names[3] = Sara Ali</p></blockquote><h6 id="C-指向指针的指针（多级间接寻址）"><a href="#C-指向指针的指针（多级间接寻址）" class="headerlink" title="C++指向指针的指针（多级间接寻址）"></a>C++指向指针的指针（多级间接寻址）</h6><p>指向指针的指针是一种多级间接寻址的形式，或者说是一个指针链。通常情况下，一个指针包括一个变量的地址。当我们定义一个指向指针的指针时，第一个指针包括了第二个指针的地址，第二个指针指向包含实际值的位置。</p><p>一个指向指针的指针变量必须如下声明，即在变量名前放置两个星号。例如，下面声明了一个指向int类型指针的指针：</p><blockquote><p>int **var;</p></blockquote><p>当一个目标值被一个指针间接指向到另一个指针的时候，访问这个值需要使用两个星号运算符，如下面的实例所示：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> var<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">*</span>ptr<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">*</span>pptr<span class="token punctuation">;</span>var <span class="token operator">=</span> <span class="token number">3000</span><span class="token punctuation">;</span><span class="token comment">// 获取var的地址</span>ptr<span class="token operator">=</span><span class="token operator">&amp;</span>var<span class="token punctuation">;</span><span class="token comment">// 使用运算符&amp;获取ptr的地址</span>pptr <span class="token operator">=</span> <span class="token operator">&amp;</span>ptr<span class="token punctuation">;</span><span class="token comment">// 使用pptr获取值</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"var 值为:"</span> <span class="token operator">&lt;&lt;</span> var <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"*ptr 值为:"</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>ptr <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"**pptr 值为:"</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span><span class="token operator">*</span>pptr <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码执行后的运行结果：</p><blockquote><p>var 值为: 3000</p><p>*ptr 值为: 3000</p><p>**pptr 值为: 3000</p></blockquote><h6 id="C-传递指针给函数"><a href="#C-传递指针给函数" class="headerlink" title="C++传递指针给函数"></a>C++传递指针给函数</h6><p>C++允许用户传递指针给函数，只需要声明函数参数为指针类型就可以。在像下面的实例中，进行了传递一个无符号的long型指针给函数，并在函数内改变这个值：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;ctime&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">getSeonds</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token operator">*</span>par<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> sec<span class="token punctuation">;</span><span class="token function">getSeconds</span><span class="token punctuation">(</span> <span class="token operator">&amp;</span>sec <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 输出实际值</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Number of seconds:"</span> <span class="token operator">&lt;&lt;</span> sec <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">getSeconds</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token operator">*</span>par<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">// 获取当前的秒数</span><span class="token operator">*</span>par <span class="token operator">=</span> <span class="token function">time</span><span class="token punctuation">(</span> <span class="token constant">NULL</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当上述代码被执行的时候产生的结果如下：</p><blockquote><p>Number of seconds : 1294450468</p></blockquote><p>能接受指针作为参数的函数，也能接受数组作为参数，如下所示：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token comment">// 函数声明</span><span class="token keyword">double</span> <span class="token function">getAverage</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>arr<span class="token punctuation">,</span> <span class="token keyword">int</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">// 带有5个元素的整形数组</span><span class="token keyword">int</span> balance<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1000</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">17</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">double</span> avg<span class="token punctuation">;</span><span class="token comment">// 传递一个指向数组的指针作为参数</span>avg <span class="token operator">=</span> <span class="token function">getAverage</span><span class="token punctuation">(</span> balance<span class="token punctuation">,</span> <span class="token number">5</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 输出返回值</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Average value is:"</span> <span class="token operator">&lt;&lt;</span> avg <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">double</span> <span class="token function">getAverage</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>arr<span class="token punctuation">,</span> <span class="token keyword">int</span> size<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> i<span class="token punctuation">,</span>sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">double</span> avg<span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>sum <span class="token operator">+=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span>avg <span class="token operator">=</span> <span class="token keyword">double</span><span class="token punctuation">(</span>sum<span class="token punctuation">)</span> <span class="token operator">/</span> size<span class="token punctuation">;</span><span class="token keyword">return</span> avg<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码执行后会产生如下结果：</p><blockquote><p>Average value is:214.4</p></blockquote><h5 id="C-从函数返回指针"><a href="#C-从函数返回指针" class="headerlink" title="C++从函数返回指针"></a>C++从函数返回指针</h5><p>C++允许从函数返回指针，为了做到这点，需要先声明一个返回指针的函数：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token operator">*</span><span class="token function">myFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>另外，C++不支持在函数外返回局部变量的地址，除非定义局部变量为staic变量。</p><p>下面的函数会生成10个随机数，并且使用表示指针的数组名（即第一个数组元素的地址）来返回他们，具体写法如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;ctime&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;cstdlib&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token comment">// 要生成和返回随机数的函数</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token function">getRandom</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">static</span> <span class="token keyword">int</span> r<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// 设置种子</span><span class="token function">srand</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span><span class="token punctuation">)</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>r<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> r<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">return</span> r<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 要调用上面定义函数的主函数</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">// 一个指向整数的指针</span><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>p <span class="token operator">=</span> <span class="token function">getRandom</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"*(p +"</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">") :"</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span><span class="token punctuation">(</span>p <span class="token operator">+</span> i<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码执行的时候会生成如下结果</p><blockquote><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token number">624723190</span><span class="token number">1468735695</span><span class="token number">807113585</span><span class="token number">976495677</span><span class="token number">613357504</span><span class="token number">1377296355</span><span class="token number">1530315259</span><span class="token number">1778906708</span><span class="token number">1820354158</span><span class="token number">667126415</span><span class="token operator">*</span><span class="token punctuation">(</span>p <span class="token operator">+</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token number">624723190</span><span class="token operator">*</span><span class="token punctuation">(</span>p <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token number">1468735695</span><span class="token operator">*</span><span class="token punctuation">(</span>p <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token number">807113585</span><span class="token operator">*</span><span class="token punctuation">(</span>p <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token number">976495677</span><span class="token operator">*</span><span class="token punctuation">(</span>p <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token number">613357504</span><span class="token operator">*</span><span class="token punctuation">(</span>p <span class="token operator">+</span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token number">1377296355</span><span class="token operator">*</span><span class="token punctuation">(</span>p <span class="token operator">+</span> <span class="token number">6</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token number">1530315259</span><span class="token operator">*</span><span class="token punctuation">(</span>p <span class="token operator">+</span> <span class="token number">7</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token number">1778906708</span><span class="token operator">*</span><span class="token punctuation">(</span>p <span class="token operator">+</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token number">1820354158</span><span class="token operator">*</span><span class="token punctuation">(</span>p <span class="token operator">+</span> <span class="token number">9</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token number">667126415</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++函数整理</title>
      <link href="/2022/11/25/c-han-shu-zheng-li/"/>
      <url>/2022/11/25/c-han-shu-zheng-li/</url>
      
        <content type="html"><![CDATA[<h3 id="C-函数"><a href="#C-函数" class="headerlink" title="C++函数"></a>C++函数</h3><p>函数主要分为两个部分，分别是函数声明和函数定义</p><p>在函数声明部分告诉了编译器函数的名称、返回类型和参数。函数定义提供了函数的实际主体。</p><h5 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h5><p>C++基本的函数定义方式如下</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">return_type function_name( parameter list ){body of the function}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在C++中，函数由一个函数头和一个函数主题组成其中</p><ul><li>返回类型：一个函数可以返回一个值。在上述描述的函数中return_type是函数返回的数据类型，有些函数执行所需要的操作而不返回值，在这种情况下，return_type是关键字void</li><li>函数名称：这是函数的实际名称。函数名和参数列表以其构成了函数签名</li><li>参数：参数类似于占位符。当函数被调用的时候，用户向参数传递一个值，这个值被称为实际参数。参数列表包括函数参数的类型、顺序、数量。参数是可以选选择的，也就是说函数可能不包含参数。</li><li>函数主题：函数主题包括一组定义函数执行任务的语句</li></ul><h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5><p>通过max()函数的源代码，来对比两个函数参数num1和num2，返回这两个数中较大的那个数</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 函数返回两个数中较大的那个数</span><span class="token keyword">int</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token keyword">int</span> num1<span class="token punctuation">,</span> <span class="token keyword">int</span> num2<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">// 局部变量声明</span><span class="token keyword">int</span> result<span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>num1 <span class="token operator">&gt;</span> num2<span class="token punctuation">)</span><span class="token punctuation">{</span>result <span class="token operator">=</span> num1<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>result <span class="token operator">=</span> num2<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h5><p>在函数声明中会明确告诉编译器函数名称以及如何调用函数。函数的实际主体可以单独进行定义</p><p>函数声明包括如下部分</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">return_type <span class="token function">function_name</span><span class="token punctuation">(</span>parameter list<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>针对上面定义的函数max()，以下是函数声明：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">man</span><span class="token punctuation">(</span><span class="token keyword">int</span> num1<span class="token punctuation">,</span><span class="token keyword">int</span> num2<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在函数声明中，参数的名称并不重要，只有参数的类型是必须的，因此下面也是有效的声明：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当在一个源文件中定义函数并且在另一个文件中调用函数的时候，函数声明是必须的，在这种情况下，用户应该在调用函数的文件顶部声明函数</p><h5 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h5><p>创建C++函数的时候，会定义函数做什么，然后通过调用函数来完成已经定义了的任务</p><p>当程序调用函数的时候，程序的控制权会转移给被调用的函数。被调用的函数执行已定义的任务，当函数的返回语句被执行的时候，或者到达函数的结束括号时，会把程序控制权交还给主程序</p><p>调用函数的时候，传递所需要的参数，如果函数返回一个值，则可以存储返回值</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token expression"><span class="token operator">&lt;</span>iostream<span class="token operator">&lt;</span></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token comment">// 函数声明</span><span class="token keyword">int</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token keyword">int</span> num1<span class="token punctuation">,</span> <span class="token keyword">int</span> num2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">// 局部变量声明</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span><span class="token keyword">int</span> ret<span class="token punctuation">;</span><span class="token comment">// 调用函数来获取最大值</span>ret <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Max value is : "</span> <span class="token operator">&lt;&lt;</span> ret <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 函数返回两个数中较大的那个数</span><span class="token keyword">int</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token keyword">int</span> num1<span class="token punctuation">,</span> <span class="token keyword">int</span> num2<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">// 局部变量声明</span><span class="token keyword">int</span> result<span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>num1 <span class="token operator">&gt;</span> num2<span class="token punctuation">)</span><span class="token punctuation">{</span>result <span class="token operator">=</span> num1<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>result <span class="token operator">=</span> num2<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将max()函数和main()函数放一块，编译源代码。所生成的结果为</p><blockquote><p>Max value is : 200</p></blockquote><h5 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h5><p>如果函数要使用参数，就必须接受参数值的变量，这些变量称为函数的形式参数</p><p>形式参数就像是函数内的其他局部变量，在进入函数时被创建，退出函数时被销毁</p><p>当调用函数时，有两种向函数传递参数的方法</p><table><thead><tr><th>调用类型</th><th>描述</th></tr></thead><tbody><tr><td>传值调用</td><td>该方法把参数的实际值复制给函数的新形式参数。在这种情况下，修改函数内的形式参数对实际参数没有影响。</td></tr><tr><td>指针调用</td><td>该方法把参数的地址复制给形式参数。在函数内，该地址用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。</td></tr><tr><td>引用调用</td><td>该方法把参数的引用复制给形式参数。在函数内，该引用用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数</td></tr></tbody></table><p>在默认情况下，C++使用传值调用来传递参数。一般来说，这意味着函数内的代码不能改变用于调用函数的参数。之前所提到的实例，调用max()函数的时候，也使用了相同的方法</p><h5 id="参数的默认值"><a href="#参数的默认值" class="headerlink" title="参数的默认值"></a>参数的默认值</h5><p>当用户定义一个函数，您可以为参数列表中后边的每一个参数指定默认值。当调用函数的时候，如果实际参数的值留空，则使用这个默认值</p><p>这是通过在函数定义中使用赋值运算符来为参数赋值的。调用参数的时候，如果为传递参数的值，则会使用默认值，如果制定了值，则会忽略默认值，使用传递的值</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> result<span class="token punctuation">;</span>result <span class="token operator">=</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">// 局部变量声明</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span><span class="token keyword">int</span> result<span class="token punctuation">;</span><span class="token comment">// 调用函数来添加值</span>result <span class="token operator">=</span> <span class="token function">sum</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Total value is :"</span><span class="token operator">&lt;&lt;</span> result <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment">// 再次调用函数</span>result <span class="token operator">=</span> <span class="token function">sum</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Total value is :"</span><span class="token operator">&lt;&lt;</span> result <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当上述代码执行后输出结果为</p><blockquote><p>Total value is :300</p><p>Total value is :120</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件工程笔记</title>
      <link href="/2022/09/09/ruan-jian-gong-cheng-bi-ji/"/>
      <url>/2022/09/09/ruan-jian-gong-cheng-bi-ji/</url>
      
        <content type="html"><![CDATA[<h4 id="软件工程是什么"><a href="#软件工程是什么" class="headerlink" title="软件工程是什么"></a>软件工程是什么</h4><p>软件工程是指导计算机软件开发与维护的工程学科，它采用工程的概念、原理、技术和方法来开发与维护软件，把经过时间考验而证明正确的管理技术和当前能够得到的最好的技术方法结合起来，以便经济地开发出高质量的软件并有效地维护它。</p><h4 id="软件工程的主要内容"><a href="#软件工程的主要内容" class="headerlink" title="软件工程的主要内容"></a>软件工程的主要内容</h4><p><strong>方法与技术</strong>：软件开发方法主要讨论软件开发的各种方法及其工作模型。同时讨论具体实现的技术</p><p><strong>工具及环境</strong>：软件工具为软件工程方法提供了支持，研究计算机辅助软件工程CASE，建立软件工程环境</p><p><strong>管理技术</strong>：软件工程管理是指对软件工程全过程的控制和管理，包括计划安排、成本估算、项目管理和软件质量管理</p><p><strong>标准与规范</strong>：软件工程标准化与规范化，使得各层工作有章可循，以保证软件生产率和软件质量的提高</p><h4 id="软件的发展阶段"><a href="#软件的发展阶段" class="headerlink" title="软件的发展阶段"></a>软件的发展阶段</h4><p>程序——程序+文档——软件工程</p><h4 id="软件定义"><a href="#软件定义" class="headerlink" title="软件定义"></a>软件定义</h4><p>软件=程序+数据+文档</p><p>程序：为了解决某个特定问题而用程序设计语言描述的适合计算机处理的语句序列</p><p>数据：使程序正常执行所需、能正常操纵信息的数据结构</p><p>文档：与程序开发、维护和使用有关的图文材料，即软件开发活动的记录</p><h4 id="软件危机的定义"><a href="#软件危机的定义" class="headerlink" title="软件危机的定义"></a>软件危机的定义</h4><p>计算机软件的开发和维护过程所遇到的一系列严重问题。</p><h4 id="软件危机的表现"><a href="#软件危机的表现" class="headerlink" title="软件危机的表现"></a>软件危机的表现</h4><p>对软件开发成本和进度的估算很不准确</p><p>用户很不满意</p><p>质量很不可靠</p><p>没有适当的文档</p><p>软件成本比重上升</p><p>供不应求：软件开发生产率跟不上计算机应用迅速深入的趋势</p><h4 id="软件危机产生原因"><a href="#软件危机产生原因" class="headerlink" title="软件危机产生原因"></a>软件危机产生原因</h4><h5 id="客观原因："><a href="#客观原因：" class="headerlink" title="客观原因："></a>客观原因：</h5><p>软件本身特点</p><p>逻辑部件</p><p>规模庞大</p><p>维护费用急剧上升</p><p>生产技术进步缓慢</p><h5 id="主观原因："><a href="#主观原因：" class="headerlink" title="主观原因："></a>主观原因：</h5><p>不正确的开发方法</p><p>忽视需求分析</p><p>错误认为：软件开发=程序编写</p><p>轻视软件维护</p><h4 id="两类软件工程泛型的简单比较"><a href="#两类软件工程泛型的简单比较" class="headerlink" title="两类软件工程泛型的简单比较"></a>两类软件工程泛型的简单比较</h4><h5 id="传统软件工程"><a href="#传统软件工程" class="headerlink" title="传统软件工程"></a>传统软件工程</h5><p>软件分析——总体设计——详细设计——面向过程的编码——测试</p><h5 id="面向对象软件工程"><a href="#面向对象软件工程" class="headerlink" title="面向对象软件工程"></a>面向对象软件工程</h5><p>软件分析与对象抽取——对象详细设计——面向对象的编码——测试</p><h4 id="软件开发模型"><a href="#软件开发模型" class="headerlink" title="软件开发模型"></a>软件开发模型</h4><h5 id="传统开发模型"><a href="#传统开发模型" class="headerlink" title="传统开发模型"></a>传统开发模型</h5><p>瀑布模型（waterfall model）</p><p>快速原型模型（rapid prototype model）</p><h5 id="演化开发模型"><a href="#演化开发模型" class="headerlink" title="演化开发模型"></a>演化开发模型</h5><p>增量模型（incremental model）</p><p>螺旋模型（spiral model）</p><h5 id="面向对象开发模型"><a href="#面向对象开发模型" class="headerlink" title="面向对象开发模型"></a>面向对象开发模型</h5><p>构件集成模型（component integration model） </p><h5 id="形式化开发模型"><a href="#形式化开发模型" class="headerlink" title="形式化开发模型"></a>形式化开发模型</h5><p>转换模型（transformational model）</p><p>净室模型（cleanroommodel）</p><h4 id="软件生存周期的定义"><a href="#软件生存周期的定义" class="headerlink" title="软件生存周期的定义"></a>软件生存周期的定义</h4><p>一个软件从开始计划起，到废弃不用止，称为软件的生存周期</p><h5 id="包括计划、开发与运行三个时期。"><a href="#包括计划、开发与运行三个时期。" class="headerlink" title="包括计划、开发与运行三个时期。"></a>包括计划、开发与运行三个时期。</h5><p>计划时期：问题定义、可行性研究</p><p>开发时期：需求分析、系统设计、编码和测试</p><p>运行时期：系统维护阶段</p><h4 id="软件工程划分阶段的意义"><a href="#软件工程划分阶段的意义" class="headerlink" title="软件工程划分阶段的意义"></a>软件工程划分阶段的意义</h4><p>简化每一步的工作内容，使因软件规模增大而大大增加的软件复杂性变得易于控制和管理。</p><h4 id="瀑布模型的特点"><a href="#瀑布模型的特点" class="headerlink" title="瀑布模型的特点"></a>瀑布模型的特点</h4><h5 id="阶段间的顺序性和依赖性"><a href="#阶段间的顺序性和依赖性" class="headerlink" title="阶段间的顺序性和依赖性"></a>阶段间的顺序性和依赖性</h5><p>相邻两个阶段有因果关系，要求严格顺序执行</p><p>上一阶段的变换结果是下一阶段变换的输入</p><p>每个阶段都要进行阶段性评审，确认后转下一阶段</p><h5 id="推迟实现的观点"><a href="#推迟实现的观点" class="headerlink" title="推迟实现的观点"></a>推迟实现的观点</h5><p>尽可能推迟软件的编码时间</p><h5 id="质量保证的观点（文档驱动性）"><a href="#质量保证的观点（文档驱动性）" class="headerlink" title="质量保证的观点（文档驱动性）"></a>质量保证的观点（文档驱动性）</h5><p>每个阶段都要完成规定的文档</p><p>每个阶段都要对已完成的文档进行复审，尽早发现问题，消除隐患</p><h4 id="瀑布模型的优缺点"><a href="#瀑布模型的优缺点" class="headerlink" title="瀑布模型的优缺点"></a>瀑布模型的优缺点</h4><h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h5><p>可强迫开发人员采用规范的方法</p><p>严格地规定了每个阶段必须提交的文档</p><p>要求每个阶段交出的所有产品都必须经过质量保证小组的仔细验证</p><h5 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h5><p>周期长：顺序推进，环环审查</p><p>需求难以准确把握(不能准确提出和沟通、不能快速适应变化的需求)，导致返工甚至推倒重来</p><p>无法预测新引入模块的影响</p><p>最终的形式难以预料</p><p>不适合需求模糊的系统</p><h4 id="快速原型模型的优缺点"><a href="#快速原型模型的优缺点" class="headerlink" title="快速原型模型的优缺点"></a>快速原型模型的优缺点</h4><h5 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h5><p>原型驱动型</p><p>过程的交互性与迭代性</p><h5 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h5><p>用户在开发过程中可以完善对软件系统的需求</p><p>开发周期相对缩短，成本较低</p><p>有效发挥用户与开发人员之间的密切配合作用</p><p>充分体现逐步发展、逐步完善的原则</p><h5 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h5><p>频繁的需求变化会使开发过程难于管理和控制</p><p>原型的快速开发和修改对技术要求比较高，需要较好的工作基础</p><h4 id="增量模型的优缺点"><a href="#增量模型的优缺点" class="headerlink" title="增量模型的优缺点"></a>增量模型的优缺点</h4><h5 id="优点：-2"><a href="#优点：-2" class="headerlink" title="优点："></a>优点：</h5><p>能在较短的时间内向用户提交部分功能的构件</p><p>逐步增加产品功能可以使用户有较充裕的时间学习和适应新产品，减少一个全新软件可能给用户带来的冲击</p><h5 id="缺点：-2"><a href="#缺点：-2" class="headerlink" title="缺点："></a>缺点：</h5><p>增量构件的划分依赖于系统功能的构成和软件开发人员的经验</p><p>要求软件系统的体系结构具有高度的可扩充性和开放性</p><h4 id="螺旋周期的优缺点"><a href="#螺旋周期的优缺点" class="headerlink" title="螺旋周期的优缺点"></a>螺旋周期的优缺点</h4><h5 id="特点：-1"><a href="#特点：-1" class="headerlink" title="特点："></a>特点：</h5><p>瀑布模型+快速原型+风险分析</p><p>迭代过程</p><h5 id="优点：-3"><a href="#优点：-3" class="headerlink" title="优点："></a>优点：</h5><p>强调可选方案和约束条件有利于已有软件的重用</p><p>有助于把软件质量作为软件开发的一个重要目标</p><p>减少过多测试或测试不足带来的风险</p><p>维护只是模型的另一个周期，在维护和开发之间并没有本质区别</p><h5 id="缺点：-3"><a href="#缺点：-3" class="headerlink" title="缺点："></a>缺点：</h5><p>需耗费大量资金和时间用于风险评估</p><p>要求开发人员具有丰富风险评估经验和有关知识</p><p>开发过程比较复杂</p><p>给过程管理和控制带来了一定的难度</p><h4 id="可行性研究的内容"><a href="#可行性研究的内容" class="headerlink" title="可行性研究的内容"></a>可行性研究的内容</h4><p><strong>(1)</strong> 技术可行性</p><p><strong>(2)</strong> 经济可行性</p><p><strong>(3)</strong> 操作可行性</p><p><strong>(4)</strong> 社会可行性(法律可行性)</p><p><strong>(5)</strong> 抉择</p><h4 id="技术可行性及需要考虑的问题"><a href="#技术可行性及需要考虑的问题" class="headerlink" title="技术可行性及需要考虑的问题"></a>技术可行性及需要考虑的问题</h4><p>度量一个特定技术信息系统解决方案的实用性及技术资源的可用性</p><h5 id="考虑的问题"><a href="#考虑的问题" class="headerlink" title="考虑的问题"></a>考虑的问题</h5><p>(1)开发风险分析</p><p>(2)资源分析</p><p>(3)相关技术的发展（现有技术能否实现新系统，技术难点、建议采用技术的先进性）</p><h4 id="经济可行性及需要考虑的问题"><a href="#经济可行性及需要考虑的问题" class="headerlink" title="经济可行性及需要考虑的问题"></a>经济可行性及需要考虑的问题</h4><p>度量系统解决方案的性能价格比</p><h5 id="考虑的问题-1"><a href="#考虑的问题-1" class="headerlink" title="考虑的问题"></a>考虑的问题</h5><h5 id="成本-x2F-效益分析（开发、运行的成本-x2F-效益）"><a href="#成本-x2F-效益分析（开发、运行的成本-x2F-效益）" class="headerlink" title="成本/效益分析（开发、运行的成本/效益）"></a>成本/效益分析（开发、运行的成本/效益）</h5><p>有形成本、效益</p><p>无形成本、效益</p><h5 id="价值和成本的关系"><a href="#价值和成本的关系" class="headerlink" title="价值和成本的关系"></a>价值和成本的关系</h5><p>质量与价值、成本的关系</p><p>价值/成本的均衡</p><h4 id="操作可行性"><a href="#操作可行性" class="headerlink" title="操作可行性"></a>操作可行性</h4><p>用户使用可能性</p><p>时间进度可行性</p><p>组织和文化上的可行性</p><h4 id="可行性研究过程"><a href="#可行性研究过程" class="headerlink" title="可行性研究过程"></a>可行性研究过程</h4><p>复查系统规模和目标</p><p>研究目前正在使用的系统</p><p>导出新系统的高层逻辑模型</p><p>进一步定义问题</p><p>导出和评价供选择的解法</p><p>推荐行动方针</p><p>草拟开发计划</p><p>书写文档提交审查</p><h4 id="软件设计概述"><a href="#软件设计概述" class="headerlink" title="软件设计概述"></a>软件设计概述</h4><p>主要介绍软件设计的一般概念，包括软件设计的任务、基本原理、模块化设计和设计文档等内容。其中这些概念是用于任何的开发方法和开发过程。</p><h5 id="软件设计的任务"><a href="#软件设计的任务" class="headerlink" title="软件设计的任务"></a>软件设计的任务</h5><p>把分析阶段产生的软件需求说明转换为用适当手段表示软件设计文档</p><h5 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h5><p>数据设计（信息模型）体系结构设计（定义软件主要组成部件之间的关系）接口设计（软件内部、外部与人之间的通信（数据流和控制流））过程设计（将软件体系结构的组成部分转变为对软件组件的过程性描述）</p><h5 id="模块（Module）"><a href="#模块（Module）" class="headerlink" title="模块（Module）"></a>模块（Module）</h5><p>是一个拥有明确定义的输入、输出和特征的程序实体。如函数、过程、子程序、宏等</p><h5 id="软件构件（SoftwareComponent）"><a href="#软件构件（SoftwareComponent）" class="headerlink" title="软件构件（SoftwareComponent）"></a>软件构件（SoftwareComponent）</h5><p>可重复使用的软件组件，现有的可复用构件，大多是在对象的基础上创建的。</p><h5 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h5><p>提取客观事件中一群事物的某些本质共性，而暂时忽略他们的非本质的细节，是一个从特殊到一般的过程。分层次考虑和处理问题（数据和过程）。</p><h6 id="过程抽象："><a href="#过程抽象：" class="headerlink" title="过程抽象："></a>过程抽象：</h6><p>把完成一个特定功能的动作序列抽象为一个过程名和参数表，以后通过指定过程名和实际参数调用此过程。</p><h6 id="数据抽象："><a href="#数据抽象：" class="headerlink" title="数据抽象："></a>数据抽象：</h6><p>把一个数据对象的定义抽象为一个数据类型名，用此类型名可以定义多个具有相同性质的数据对象。</p><h5 id="信息隐藏"><a href="#信息隐藏" class="headerlink" title="信息隐藏"></a>信息隐藏</h5><h6 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h6><p>把系统分解为模块时应遵守的指导思想</p><h6 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h6><p>模块内部的数据和过程，不需要这些信息的模块不可访问；每一个模块只完成一个相对独立的特定功能；模块之间渐渐交换那些完成系统功能必须交换的信息。</p><h6 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h6><p>提高模块的独立性，当修改或者维护模块时减少把一个模块的错误扩散到其他模块中去的机会。</p><h4 id="模块化设计"><a href="#模块化设计" class="headerlink" title="模块化设计"></a>模块化设计</h4><h5 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h5><p>把大型软件按照规定的原则划分成一个个较小的相对独立但又相互关联的模块。</p><h5 id="指导思想："><a href="#指导思想：" class="headerlink" title="指导思想："></a>指导思想：</h5><p>分解；模块独立化</p><h5 id="内容："><a href="#内容：" class="headerlink" title="内容："></a>内容：</h5><p>分解；模块独立性；自顶向下与由底向上</p><h5 id="内聚"><a href="#内聚" class="headerlink" title="内聚"></a>内聚</h5><p>低内聚 中内聚 高内聚 逻辑性内聚 通信性内聚</p><h5 id="耦合"><a href="#耦合" class="headerlink" title="耦合"></a>耦合</h5><p>弱耦合 中耦合 较强耦合 强耦合</p><h5 id="复审"><a href="#复审" class="headerlink" title="复审"></a>复审</h5><p>概要设计复审</p><p>系统的总体结构，模块划分，内外接口</p><p>详细设计复审</p><p>各个模块的具体设计</p><h5 id="复审的方式"><a href="#复审的方式" class="headerlink" title="复审的方式"></a>复审的方式</h5><p>正式复审</p><p>非正式复审</p><p>走查</p><h4 id="面向数据流设计"><a href="#面向数据流设计" class="headerlink" title="面向数据流设计"></a>面向数据流设计</h4><p>将信息流映射成软件结构，数据流是考虑一切问题的出发点，最终目的是</p><h6 id="给出设计软件结构的一个系统化的途径"><a href="#给出设计软件结构的一个系统化的途径" class="headerlink" title="给出设计软件结构的一个系统化的途径"></a>给出设计软件结构的一个系统化的途径</h6><p>数据流的类型决定映射方法</p><h6 id="变换流"><a href="#变换流" class="headerlink" title="变换流"></a>变换流</h6><h6 id="事务流"><a href="#事务流" class="headerlink" title="事务流"></a>事务流</h6><p>该方法适用于概要设计阶段</p><p>常称为结构化设计（SD）方法</p><h4 id="面向数据设计"><a href="#面向数据设计" class="headerlink" title="面向数据设计"></a>面向数据设计</h4><p>该方法不明显的使用软件结构的概念，模块是设计过程的副产品。对于模块独立性也没有给予应有的重视</p><p>以数据结构作为分析和设计的基础</p><p>最终目标</p><h6 id="得出程序的过程性描述"><a href="#得出程序的过程性描述" class="headerlink" title="得出程序的过程性描述"></a>得出程序的过程性描述</h6><p>该方法适用于过程设计/详细设计阶段</p><p>主要涉及方法</p><h6 id="Jackson方法"><a href="#Jackson方法" class="headerlink" title="Jackson方法"></a>Jackson方法</h6><h6 id="Warnier方法"><a href="#Warnier方法" class="headerlink" title="Warnier方法"></a>Warnier方法</h6><h4 id="结构化设计与结构化分析的关系"><a href="#结构化设计与结构化分析的关系" class="headerlink" title="结构化设计与结构化分析的关系"></a>结构化设计与结构化分析的关系</h4><p>软件设计必须依据对软甲你的需求来进行，结构化分析的结果为结构化设计提供了最基本的输入信息</p><p>分析模型的每个元素都提供了创建设计模型时候所需要的信息</p><p>数据设计吧分析阶段创建的信息域模型转变成显示软件所需要的数据结构</p><p>体系结构设计确定了程序设计的主要结构元素（即程序构建）之间的关系</p><p>接口设计的结构描述了软件内部、软件与协作系统之间以及软件与使用者之间的通信方式</p><p>过程设计把程序体系结构中的结构元素，变换成对软件构件的过程性描述</p><p>在软件设计期间我们所作出的决策，将最终决定软件开发能否成功，更重要的是，这些设计决策将决定软件维护的难易程度</p><h4 id="SC图"><a href="#SC图" class="headerlink" title="SC图"></a>SC图</h4><h5 id="SC图的组成符号"><a href="#SC图的组成符号" class="headerlink" title="SC图的组成符号"></a>SC图的组成符号</h5><p>矩形框来表示模块</p><p>带箭头的连线表示模块间的调用关系</p><p>在调用线的两旁标出传入和传出模块的数据流</p><h5 id="SC图中的模块符号"><a href="#SC图中的模块符号" class="headerlink" title="SC图中的模块符号"></a>SC图中的模块符号</h5><p>传入；传出；变换；源；漏；控制</p><h5 id="SC图中的模块调用"><a href="#SC图中的模块调用" class="headerlink" title="SC图中的模块调用"></a>SC图中的模块调用</h5><p>简单调用：调用线的箭头指向被调用的模块</p><p>选择调用：图中用菱形符号表示选择</p><p>循环调用：用叠加在调用线初始端的环形箭头表示循环</p><p>在结构图中通常还用带注释的箭头表示模块调用过程中来回传递的信息。如果希望进一步标明传递的信息是数据还是控制信息，则可以利用注释箭头尾部的形状来区分：尾部是空心圆表示传递的是数据，实心圆表示传递的是控制信息</p><p><strong>层次图和结构图并不严格表示模块的调用次序。</strong></p><p><strong>层次图和结构图并不指明什么时候调用下层模块。</strong> </p><p> 通常用层次图作为描绘软件结构的文档。结构图作为文档并不合适。但是，利用IPO图和数据字典中的信息得到模块调用时传递的信息，从而由层次图导出结构图的过程，却可以作为检察设计正确性和评价模块独立性的好方法。</p><h4 id="变换型结构"><a href="#变换型结构" class="headerlink" title="变换型结构"></a>变换型结构</h4><p>变换中心：通过计算或者处理，将系统的传入流变为传出流。又称为加工中心。传入流：离输入始端最远但是仍然可以被看做系统输入的那些数据流。输出流：离输出末端最远但仍可以被看作系统输出的那些数据流。</p><h4 id="变换映射"><a href="#变换映射" class="headerlink" title="变换映射"></a>变换映射</h4><p>适用于将变换型结构的DFD图转换为初始软件结构图</p><p>区分传出、传入和变换中心三个部分，在DFD图上表明它们的分界线</p><p>变换中心的任务：通过计算或者处理，把系统的逻辑输入变换（或加工）为系统的逻辑输出</p><p>逻辑输入（传入数据项）：离物理输入端（输入始端）最远，但仍然可以被看作是系统输入的那些数据流。</p><p>逻辑输出（传出数据项）：离物理输出端（输出末端）最远，但是仍可以被看作系统输出的那些数据流。数据在系统中流动的时候，不仅咋痛殴该国变化中心时要被变换，在传入路径和传出路径上，其内容和形式也可能发生变化。故变换中心又称为“中心加工”，以区别于数据在传入传出过程中的其他加工</p><p>划分的结构可能会受经验的影响，但是必须从实际情况出发，对DFD图作认真和细致的分析</p><h5 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h5><p>有些系统没有中心加工，系统的逻辑输入和逻辑输出是完全仙童的数据流，应该将DFD划分为传入和传出两本分，不要强求一律硬分成为三个部分。</p><p>除了传入部份外，在变化中心甚至传出部分也可能从系统外接受某些输入数据流，成为二次传入数据。该数据不应当做传入部分的一部分。</p><p>有些DFD图可能失之太粗，缺少应有的细节，可考虑对自己用于分析的DFD进行补充。</p><h4 id="事务映射"><a href="#事务映射" class="headerlink" title="事务映射"></a>事务映射</h4><p>虽然在任何请胯下都可以使用变换分析方法设计软件结构，但是在数据流具有明显的事务特点时，也就是有一个明显的“发射中心”（事务中心）时，还是以采用事务分析方法为宜</p><p>事务：引发、触发或者启动某一动作或者一串动作的任何数据、控制、信号、事件或者状态的变化。</p><h5 id="事务分析步骤："><a href="#事务分析步骤：" class="headerlink" title="事务分析步骤："></a>事务分析步骤：</h5><p>1.在DFD图上确定事务中心、接收部分（包括接受路径）和发送部分（包括全部动作路径）</p><p>事务中心通常位于DFD图中多条动作路径的起点；向事务中心提供信息的路径，是系统的接受路径；</p><p>动作路径通常不止一条，切每条均具有自己的结构特性（变换或事务型）</p><p>2.画出SC图的框架，把DFD图的三个部分分别映射为事务控制模块、接收模块和动作发送模块</p><p>3.分解和细化接收和发送分支，完成初始的SC图</p><p>接受分支一般具有变换特性，可对其进行变换分析；</p><p>动作分支经典的可映射为4层：处理层、事务层、操作层、细节层、</p><p>在大型系统的DFD中，变换型和事务型两类结构往往同时存在。对于一个大系统，常常把变换分析和事务分析应用到同一个数据流图的不同部分，由此可得到的子结构形成“构建”，可以利用他们构建完整的软件结构。</p><h5 id="改进软件结构提高模块独立性"><a href="#改进软件结构提高模块独立性" class="headerlink" title="改进软件结构提高模块独立性"></a>改进软件结构提高模块独立性</h5><p>通过模块分解或合并，力求降低耦合提高内聚</p><h5 id="模块规模应该适中"><a href="#模块规模应该适中" class="headerlink" title="模块规模应该适中"></a>模块规模应该适中</h5><p>过大，可考虑继续分解模块功能，过小，可考虑合并到上层模块。</p><h4 id="深度、宽度、扇出和扇入都应适当"><a href="#深度、宽度、扇出和扇入都应适当" class="headerlink" title="深度、宽度、扇出和扇入都应适当"></a>深度、宽度、扇出和扇入都应适当</h4><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><p>深度：软件结构中控制的层数，往往粗略的标志一个系统的大小和复杂程度。越大，意味着模块功能可能过分简单，软件的程序控制复杂</p><p>宽度：软件结构内同一个层次上的模块总数的最大值。快读越大系统越复杂</p><p>扇出：模块直接调用的下级模块数目，也成为模块的控制宽度</p><p>扇入：直接调用他的上级模块数</p><h4 id="模块的作用域应该在控制域之内"><a href="#模块的作用域应该在控制域之内" class="headerlink" title="模块的作用域应该在控制域之内"></a>模块的作用域应该在控制域之内</h4><h5 id="两个范围的定义"><a href="#两个范围的定义" class="headerlink" title="两个范围的定义"></a>两个范围的定义</h5><p>控制范围：包括模块自身及其下属模块，不论这些模块系统由该模块直接调用，还是间接调用</p><p>作用范围：是一个与条件判定相联系的概念，指模块内的某条件判定涉及的直接调用和间接调用模块。</p><p>一般情况，一个盘底你个作用范围内的模块可能会有三种情况</p><h6 id="整个模块是否执行，依赖于判定的结果"><a href="#整个模块是否执行，依赖于判定的结果" class="headerlink" title="整个模块是否执行，依赖于判定的结果"></a>整个模块是否执行，依赖于判定的结果</h6><h6 id="上述模块的下属模块"><a href="#上述模块的下属模块" class="headerlink" title="上述模块的下属模块"></a>上述模块的下属模块</h6><h6 id="模块内有部分功能的执行依赖于这一判定"><a href="#模块内有部分功能的执行依赖于这一判定" class="headerlink" title="模块内有部分功能的执行依赖于这一判定"></a>模块内有部分功能的执行依赖于这一判定</h6><h5 id="作用范围-x2F-控制范围原则"><a href="#作用范围-x2F-控制范围原则" class="headerlink" title="作用范围/控制范围原则"></a>作用范围/控制范围原则</h5><p>把一个判定的作用范围限制在判定所在模块的控制范围之内，是改进模块结构的基本原则</p><p>理想情况，是使判定的作用范围和判定所在模块的控制范围尽可能的吻合</p><h5 id="把系统中有较大影响的判定放在层次结构中较低的位置，可能是导致违反作用范围-x2F-控制范围原则的主要原因。"><a href="#把系统中有较大影响的判定放在层次结构中较低的位置，可能是导致违反作用范围-x2F-控制范围原则的主要原因。" class="headerlink" title="把系统中有较大影响的判定放在层次结构中较低的位置，可能是导致违反作用范围/控制范围原则的主要原因。"></a>把系统中有较大影响的判定放在层次结构中较低的位置，可能是导致违反作用范围/控制范围原则的主要原因。</h5><p>所以要么把这类重要的判定从低层次上移到做够高的上层模块中，要么把受这些判定影响的模块调整并向下移动到控制范围之内</p><h5 id="力争降低模块接口的复杂程度"><a href="#力争降低模块接口的复杂程度" class="headerlink" title="力争降低模块接口的复杂程度"></a>力争降低模块接口的复杂程度</h5><p>模块接口复杂是软件发生错误的一个主要原因。设计接口时，应使得信息传递简单并且和模块的功能一致。</p><p>接口复杂或者不一致（即看起来传递的数据之间没有联系），是紧耦合或者低内聚的征兆，应该重新分析这个模块的独立性。</p><h5 id="设计单入口单出口的模块"><a href="#设计单入口单出口的模块" class="headerlink" title="设计单入口单出口的模块"></a>设计单入口单出口的模块</h5><p>不要涉及内容耦合模块</p><h5 id="模块功能应该可以预测"><a href="#模块功能应该可以预测" class="headerlink" title="模块功能应该可以预测"></a>模块功能应该可以预测</h5><p>模块的功能应该能够预测，但也要防止模块功能过分局限。</p>]]></content>
      
      
      <categories>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity游戏开发Time函数描述整理</title>
      <link href="/2022/09/05/unity-you-xi-kai-fa-time-han-shu-miao-shu-zheng-li/"/>
      <url>/2022/09/05/unity-you-xi-kai-fa-time-han-shu-miao-shu-zheng-li/</url>
      
        <content type="html"><![CDATA[<h1 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h1><h4 id="Time-captureDeltaTime"><a href="#Time-captureDeltaTime" class="headerlink" title="Time.captureDeltaTime"></a>Time.captureDeltaTime</h4><p>减慢应用程序的播放时间，以允许Unity在帧之间保存屏幕截图。如果此属性具有非零值，则Time.time会以captureDeltaTime的间隔（由Time.timeScale缩放）增加，而不管实时时间和帧的持续时间。如果您想要捕捉需要恒定帧速率的电影并且想要在帧之间留出足够的时间来保存屏幕图像，这将非常有用</p><p>captureDeltaTime函数对于Time.unscaledTime没有任何影响。</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using UnityEngine;using System.Collections;// Capture frames as a screenshot sequence. Images are// stored as PNG files in a folder - these can be combined into// a movie using image utility software (eg, QuickTime Pro).public class ExampleClass : MonoBehaviour{    // The folder to contain our screenshots.    // If the folder exists we will append numbers to create an empty folder.    public string folder = "ScreenshotFolder";    public int frameRate = 25;    void Start()    {        // Set the playback framerate (real time will not relate to game time after this).        Time.captureDeltaTime = 1.0f / frameRate;        // Create the folder        System.IO.Directory.CreateDirectory(folder);    }    void Update()    {        // Append filename to folder name (format is '0005 shot.png"')        string name = string.Format("{0}/{1:D04} shot.png", folder, Time.frameCount);        // Capture the screenshot to the specified file.        ScreenCapture.CaptureScreenshot(name);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Time-captureFramerate"><a href="#Time-captureFramerate" class="headerlink" title="Time.captureFramerate"></a>Time.captureFramerate</h4><p>是Time. captureDeltaTime的倒数，captureFramerate等效于将（1.0/Time.captureDeltaTime）四舍五入到最接近的整数。设置captureFramerate还会将Time.captureDeltaTime设置为等效的倒数，请注意，captureFramerate的值为零相当于captureDeltaTime的值为零</p><h4 id="Time-deltaTime"><a href="#Time-deltaTime" class="headerlink" title="Time.deltaTime"></a>Time.deltaTime</h4><p>从最后一帧到当前帧的间隔（以秒为单位）</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using UnityEngine;// Rotate around the z axis at a constant speedpublic class ConstantRotation:MonoBehaviour{public float degreesPerSecond=2.0f;void Update(){transform.Rotate(0,0,degreesPerSecond*Time.deltaTime);}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>本案例实现了一个计时器，计时器每一帧添加deltaTime。</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using System.Collections;using System.Collections.Generic;using UnityEngine;// Time.deltaTime example.//// Wait two seconds and display waited time.// This is typically just beyond 2 seconds.// Allow the speed of the time to be increased or decreased.// It can range between 0.5 and 2.0. These changes only// happen when the timer restarts.public class ScriptExample : MonoBehaviour{    private float waitTime = 2.0f;    private float timer = 0.0f;    private float visualTime = 0.0f;    private int width, height;    private float value = 10.0f;    private float scrollBar = 1.0f;    void Awake()    {        width = Screen.width;        height = Screen.height;        Time.timeScale = scrollBar;    }    void Update()    {        timer += Time.deltaTime;        // Check if we have reached beyond 2 seconds.        // Subtracting two is more accurate over time than resetting to zero.        if (timer &gt; waitTime)        {            visualTime = timer;            // Remove the recorded 2 seconds.            timer = timer - waitTime;            Time.timeScale = scrollBar;        }    }    void OnGUI()    {        GUIStyle sliderDetails = new GUIStyle(GUI.skin.GetStyle("horizontalSlider"));        GUIStyle sliderThumbDetails = new GUIStyle(GUI.skin.GetStyle("horizontalSliderThumb"));        GUIStyle labelDetails = new GUIStyle(GUI.skin.GetStyle("label"));        // Set the size of the fonts and the width/height of the slider.        labelDetails.fontSize = 6 * (width / 200);        sliderDetails.fixedHeight = height / 32;        sliderDetails.fontSize = 12 * (width / 200);        sliderThumbDetails.fixedHeight = height / 32;        sliderThumbDetails.fixedWidth = width / 32;        // Show the slider. Make the scale to be ten times bigger than the needed size.        value = GUI.HorizontalSlider(new Rect(width / 8, height / 4, width - (4 * width / 8), height - (2 * height / 4)),            value, 5.0f, 20.0f, sliderDetails, sliderThumbDetails);        // Show the value from the slider. Make sure that 0.5, 0.6... 1.9, 2.0 are shown.        float v = ((float)Mathf.RoundToInt(value)) / 10.0f;        GUI.Label(new Rect(width / 8, height / 3.25f, width - (2 * width / 8), height - (2 * height / 4)),            "timeScale: " + v.ToString("f1"), labelDetails);        scrollBar = v;        // Display the recorded time in a certain size.        labelDetails.fontSize = 14 * (width / 200);        GUI.Label(new Rect(width / 8, height / 2, width - (2 * width / 8), height - (2 * height / 4)),            "Timer value is: " + visualTime.ToString("f4") + " seconds.", labelDetails);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Time-fixedDeltaTime"><a href="#Time-fixedDeltaTime" class="headerlink" title="Time.fixedDeltaTime"></a>Time.fixedDeltaTime</h4><p>执行物理和其他固定帧率更新（如MonoBehaviour的FixedUpdate）的时间间隔（以秒为单位）</p><h4 id="Time-fixedTime"><a href="#Time-fixedTime" class="headerlink" title="Time.fixedTime"></a>Time.fixedTime</h4><p>自上次FixedUpdate开始以来的时间（只读）。这是游戏开始后的秒数。</p><h4 id="Time-fixedTimeAsDouble"><a href="#Time-fixedTimeAsDouble" class="headerlink" title="Time.fixedTimeAsDouble"></a>Time.fixedTimeAsDouble</h4><p>从上次FixedUpdate开始以来的双精度时间（只读）。这是游戏开始后的秒数</p><h4 id="Time-fixedUnscaledDeltaTime"><a href="#Time-fixedUnscaledDeltaTime" class="headerlink" title="Time.fixedUnscaledDeltaTime"></a>Time.fixedUnscaledDeltaTime</h4><p>从最后一个MonoBehaviour.FixedUpdate阶段到当前阶段的与时间刻度无关的间隔（以秒为单位）（只读）</p><h4 id="Time-fixedUnscaledTime"><a href="#Time-fixedUnscaledTime" class="headerlink" title="Time.fixedUnscaledTime"></a>Time.fixedUnscaledTime</h4><p>最后一个MonoBehaviour.FixedUpdate阶段开始时与timeScale无关的时间（只读）。这是游戏开始后的秒数。此值以等于Time.FixedUnscaledDeltaTime的固定增量更新，与Time.fixedTime不同，此值不受Time.timeScale影响</p><h4 id="Time-fixedUnscaledTimeAsDouble"><a href="#Time-fixedUnscaledTimeAsDouble" class="headerlink" title="Time.fixedUnscaledTimeAsDouble"></a>Time.fixedUnscaledTimeAsDouble</h4><p>上一次FixedUpdate开始时与时间刻度无关的双精度时间（只读）。这是游戏开始后的秒数，如果在单个帧中多次调用，则返回相同的值。与fixedTimeAsDouble不同，此值不受timeScale影响。fiedUnscaledTime的双精度版本。这提供了比浮点数或单个值更高的精度，尤其是在较长的实际时间段内。几乎在所有情况下，都应该使用与fixedUnscaledTime等效的fixedUnscaledTimeAsDouble</p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> Unity </tag>
            
            <tag> 游戏开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity游戏开发Mathf函数描述整理</title>
      <link href="/2022/09/04/unity-you-xi-kai-fa-mathf-han-shu-miao-shu-zheng-li/"/>
      <url>/2022/09/04/unity-you-xi-kai-fa-mathf-han-shu-miao-shu-zheng-li/</url>
      
        <content type="html"><![CDATA[<h1 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h1><h4 id="Mathf-Deg2Rad"><a href="#Mathf-Deg2Rad" class="headerlink" title="Mathf.Deg2Rad"></a>Mathf.Deg2Rad</h4><p>读到弧度的换算常量（只读），等于公式 (PI*2)/360</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using UnityEngine;using System.Collections;public class ExampleClass:MonoBehaviour{public float deg=30.0F;void Start(){float rad=def*Mathf.Deg2Rad;Debug.Log(deg+"degrees are equal to"+rad+"radians.");}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Mathf-Epsilon"><a href="#Mathf-Epsilon" class="headerlink" title="Mathf.Epsilon"></a>Mathf.Epsilon</h4><p>微小浮点值（只读），浮点数可以与0相差的最小值</p><p>介于任何数字与Epsilon之间的值会产生任意数字，因为存在截断误差。</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using UnityEngine;public class Example:MonoBehaviour{// Compares two floating point numbers and return true if they are the same number.    // See also Mathf.Approximately, which compares floating point numbers so you dont have    // to create a function to compare them.        bool isEqual(float a,float b)    {    if(a&gt;=b-Math.Epsilon &amp;&amp;a&lt;=b+Mathf.Epsilon)    {    return true;    }    else    {    return false;    }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Mathf-Infinity"><a href="#Mathf-Infinity" class="headerlink" title="Mathf.Infinity"></a>Mathf.Infinity</h4><p>正无穷大的表示形式（只读）</p><pre class="line-numbers language-C#" data-language="C#"><code class="language-C#">using UnityEngine;public class Example:MonoBehaviour{// Casts a ray from (0,0,0) towards (0,0,1) to the infinity and prints a message    // if any object has touched the ray.    // To test it, just place any object and intersect it with the white drawn line        void Update()    {//shows the line that follows the ray.Debug.DrawLine(Vector3.zero,Vector3.forward*100);if(Physics.Raycast(Vector3.zero,Vector3.forward,Mathf.Infinity)){print("There is something in front of the object!");}}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Mathf-NegativeInfinity"><a href="#Mathf-NegativeInfinity" class="headerlink" title="Mathf.NegativeInfinity"></a>Mathf.NegativeInfinity</h4><p>负无穷大的表示形式（只读）</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using UnityEngine;public class Example:MonoBehaviour{void Start(){Debug.Log(Mathf.NegativeInfinity);}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Math-PI"><a href="#Math-PI" class="headerlink" title="Math.PI"></a>Math.PI</h4><p>圆周率函数，该数值是32位浮点数，是float，可以提供大约七位数的精度</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using UnityEngine;using System.Collections;public class ExampleClass:MonoBehaviour{public float radius=5;void Start(){float perimeter=2.0f*Mathf.PI*radius;Debug.Log("The perimeter of the circle is:"+perimeter);}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Mathf-Rad2Deg"><a href="#Mathf-Rad2Deg" class="headerlink" title="Mathf.Rad2Deg"></a>Mathf.Rad2Deg</h4><p>弧度到度的换算常量（只读），公式等于360/(PI*2)</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using UnityEngine;public class MathfRad2Deg:MonoBehaviour{//convert 1 radian to degreesfloat rad=1.0f;void Start(){float deg=rad*Mathf.Rad2Deg;//This will output 1 radians are equal to 57.29578 degreesDebug.Log(rad+"radians are equal to"+deg+"degrees.");}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="静态函数"><a href="#静态函数" class="headerlink" title="静态函数"></a>静态函数</h1><h4 id="Mathf-Abs"><a href="#Mathf-Abs" class="headerlink" title="Mathf.Abs"></a>Mathf.Abs</h4><p>可以用来返回 f 的绝对值</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using UnityEngine;public class MathAbsExample:Monohaviour{void Start(){// prints 10.5Debug.Log(Mathf.Abs(-10.5f));// prints 10Debug.Log(Mathf.Abs(-10));}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Mathf-Acos"><a href="#Mathf-Acos" class="headerlink" title="Mathf.Acos"></a>Mathf.Acos</h4><p>返回 f 的反余弦-其余弦为 f 的角度（以弧度为单位）</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using UnityEngine;public class ScriptExample:MonoBehaviour{void Start(){print(Mathf.Acos(0.5f));}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Mathf-Approximately"><a href="#Mathf-Approximately" class="headerlink" title="Mathf.Approximately"></a>Mathf.Approximately</h4><p>比较两个浮点数，如果两个浮点数相似，则返回true，比较的差值处于Epsilon范围内则返回True</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using UnityEngine;public class ScriptExample:MonoBehaviour{void Start(){if(Mathf.Approximately(1.0f,10.0f/10.0f)){print("The values are approximately the same");}}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Mathf-Asin"><a href="#Mathf-Asin" class="headerlink" title="Mathf.Asin"></a>Mathf.Asin</h4><p>返回 f 的反正弦-其正弦为 f 的角度（以弧度为单位）</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using UnityEngine;public class ScriptExample:MonoBehaviour{void Start(){print(Mathf.Asin(0.5f));}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Mathf-Atan"><a href="#Mathf-Atan" class="headerlink" title="Mathf.Atan"></a>Mathf.Atan</h4><p>返回 f 的反正切-其正切为 f 的角度（以弧度为单位）</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using UnityEngine;public class ScriptExample:MonoBehaviour{void Start(){print(Mathf.Atan(0.5f));}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Mathf-Ceil"><a href="#Mathf-Ceil" class="headerlink" title="Mathf.Ceil"></a>Mathf.Ceil</h4><p>返回大于或等于 f 的最小整数</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using UnityEngine;using System.Collections;public class ExampleClass:MonoBehaviour{void Example(){        // Prints 10        Debug.Log(Mathf.Ceil(10.0F));        // Prints 11        Debug.Log(Mathf.Ceil(10.2F));        // Prints 11        Debug.Log(Mathf.Ceil(10.7F));        // Prints -10        Debug.Log(Mathf.Ceil(-10.0F));        // Prints -10        Debug.Log(Mathf.Ceil(-10.2F));        // Prints -10        Debug.Log(Mathf.Ceil(-10.7F));}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Mathf-CeilToInt"><a href="#Mathf-CeilToInt" class="headerlink" title="Mathf.CeilToInt"></a>Mathf.CeilToInt</h4><p>返回大于或等于 f 的最小整数</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using UnityEngine;using System.Collections;public class ExampleClass : MonoBehaviour{    void Start()    {        // Prints 10        Debug.Log(Mathf.CeilToInt(10.0f));        // Prints 11        Debug.Log(Mathf.CeilToInt(10.2f));        // Prints 11        Debug.Log(Mathf.CeilToInt(10.7f));        // Prints -10        Debug.Log(Mathf.CeilToInt(-10.0f));        // Prints -10        Debug.Log(Mathf.CeilToInt(-10.2f));        // Prints -10        Debug.Log(Mathf.CeilToInt(-10.7f));    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Mathf-Clamp"><a href="#Mathf-Clamp" class="headerlink" title="Mathf.Clamp"></a>Mathf.Clamp</h4><p>用于返回 float 最小值和最大值之间的浮点结果</p><p>将给定制限制在给定的最小浮点数和最大浮点数之间。如果它在最小和最大的范围内 则返回给定值。如果给定的浮点值小于最小值则返回最小值。如果给定值大于最大值，则返回最大值。</p><p>如果最小值大于最大值则该方法返回最小值。</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using UnityEngine;// Mathf.Clamp example.//// Animate a cube along the x-axis using a sine wave.// Let the minimum and maximum positions on the x-axis// be changed.  The cube will be visible inside the// minimum and maximum values.public class ExampleScript:MonoBehaviour{private float xMin-0.5f,xMax=5.0f;private float timeValue=0.0f;void Update(){// Compute the sin position.float xValue=Mathf.Sin(timeValue*5.0f);// Now compute the Clamp value.float xPos=Mathf.Clamp(xValue,xMin,xMax);// Update the position of the cube.transform.position=new Vector3(xPos,0.0f,0.0f);// Increase animation time.timeValue=timeValue+Time.deltaTime;// Reset the animation time if it is greater than theplanned time.if(xValue&gt;Mathf.PI*2.0f){timeValue=0.0f;}}void OnGUI(){// Let the minimum and maximum values be changed        xMin = GUI.HorizontalSlider(new Rect(25, 25, 100, 30), xMin, -1.0f, +1.0f);        xMax = GUI.HorizontalSlider(new Rect(25, 60, 100, 30), xMax, -1.0f, +1.0f);        // xMin is kept less-than or equal to xMax.        if (xMin &gt; xMax)        {            xMin = xMax;        }        // Display the xMin and xMax value with better size labels.        GUIStyle fontSize = new GUIStyle(GUI.skin.GetStyle("label"));        fontSize.fontSize = 24;        GUI.Label(new Rect(135, 10, 150, 30), "xMin: " + xMin.ToString("f2"), fontSize);        GUI.Label(new Rect(135, 45, 150, 30), "xMax: " + xMax.ToString("f2"), fontSize);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同样该函数还可以用作与返回 int 最小值到最大值之间的整数结果</p><p>如果 给定值在最小和最大的范围内，则返回给定值，如给定值小于最小值，则返回最小值。如果给定值大于最大值，则直接返回最大值。Min和Max参数包括在内，例如Clamp(10,0,5)将返回最大参数为5，而不是4。</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using UnityEngine;// Mathf.Clamp integer example.//// Add or subtract values from health.// Keep health between 1 and 100. Start at 17.public class ExampleScript : MonoBehaviour{    public int health = 17;    private int[] healthUp = new int[] {25, 10, 5, 1};    private int[] healthDown = new int[] {-10, -5, -2, -1};    // Width and height for the buttons.    private int xButton = 75;    private int yButton = 50;    // Place of the top left button.    private int xPos1 = 50, yPos1 = 100;    private int xPos2 = 125, yPos2 = 100;    void OnGUI()    {        GUI.skin.label.fontSize = 20;        GUI.skin.button.fontSize = 20;        // Generate and show positive buttons.        for (int i = 0; i &lt; healthUp.Length; i++)        {            if (GUI.Button(new Rect(xPos1, yPos1 + i * yButton, xButton, yButton), healthUp[i].ToString()))            {                health += healthUp[i];            }        }        // Generate and show negative buttons.        for (int i = 0; i &lt; healthDown.Length; i++)        {            if (GUI.Button(new Rect(xPos2, yPos2 + i * yButton, xButton, yButton), healthDown[i].ToString()))            {                health += healthDown[i];            }        }        // Show health between 1 and 100.        health = Mathf.Clamp(health, 1, 100);        GUI.Label(new Rect(xPos1, xPos1, 2 * xButton, yButton), "Health: " + health.ToString("D3"));    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Mathf-Clamp01"><a href="#Mathf-Clamp01" class="headerlink" title="Mathf.Clamp01"></a>Mathf.Clamp01</h4><p>将值限制在0和1之间并返回值，如果值为负，则返回0。如果值大于1，则返回1。</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using UnityEngine;public class Example:MonoBehaviour{// Set the position of the transform to be that of the time    // but never less than 0 or more than 1        void Update()    {    transform.position=new Vector3(Mathf.Clamp01(Time.time),0,0);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using System.Collections;using System.Collections.Generic;using UnityEngine;// Print a random number every second.  This number is chosen over a// range from startValue to endValue.  The random number is clamped// to between zero and one by Clamp01().public class ExampleScript:MonoBehaviour{public float startValue=-0.5f;public float endValue=1.5f;private float timeCount=0.0f;void FixedUpdate(){timeCount+=Time.deltaTime;if(timeCount&gt;1.0f){float result=Random.value;result=result*(endValue-startValue);result=result+startValue;float clampValue=Mathf.Clamp01(result); Debug.Log("value:"+result.ToString("F3")+"result:"+clampValue.ToString("F3"));timeCount=0.0f;}}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Mathf-ClosestPowerOfTwo"><a href="#Mathf-ClosestPowerOfTwo" class="headerlink" title="Mathf.ClosestPowerOfTwo"></a>Mathf.ClosestPowerOfTwo</h4><p>返回最接近的 2 的幂值</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using UnityEngine;public class Example:MonoBegaviour{void Start(){// prints 8Debug.Log(Mathf.ClosestPowerOfTwo(7));// prints 16Debug.Log(Mathf.ClosestPowerOfTwo(19));}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Mathf-CorrelatedColorTemperatureToRGB"><a href="#Mathf-CorrelatedColorTemperatureToRGB" class="headerlink" title="Mathf.CorrelatedColorTemperatureToRGB"></a>Mathf.CorrelatedColorTemperatureToRGB</h4><p>参数：kelvin 以开尔文为单位的温度</p><p>返回一个Color采用浮点RGB眼色行事的相关色温</p><p>该函数以开尔文为单位的色温转换为RGB颜色，给定相关色温，估算RGB等效值。曲线拟合误差最大为0.008</p><p>参数返回必须处于1000到40000度之间。</p><h4 id="Mathf-Cos"><a href="#Mathf-Cos" class="headerlink" title="Mathf.Cos"></a>Mathf.Cos</h4><p>返回角度 f 的余弦，返回值 float 介于 -1 和 1 之间。</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using UnityEngine;using System.Collections;public class PolyDrawExample : MonoBehaviour{    public int numberOfSides;    public float polygonRadius;    public Vector2 polygonCenter;    void Update()    {        DebugDrawPolygon(polygonCenter, polygonRadius, numberOfSides);    }    // Draw a polygon in the XY plane with a specfied position, number of sides    // and radius.    void DebugDrawPolygon(Vector2 center, float radius, int numSides)    {        // The corner that is used to start the polygon (parallel to the X axis).        Vector2 startCorner = new Vector2(radius, 0) + center;        // The "previous" corner point, initialised to the starting corner.        Vector2 previousCorner = startCorner;        // For each corner after the starting corner...        for (int i = 1; i &lt; numSides; i++)        {            // Calculate the angle of the corner in radians.            float cornerAngle = 2f * Mathf.PI / (float)numSides * i;            // Get the X and Y coordinates of the corner point.            Vector2 currentCorner = new Vector2(Mathf.Cos(cornerAngle) * radius, Mathf.Sin(cornerAngle) * radius) + center;            // Draw a side of the polygon by connecting the current corner to the previous one.            Debug.DrawLine(currentCorner, previousCorner);            // Having used the current corner, it now becomes the previous corner.            previousCorner = currentCorner;        }        // Draw the final side by connecting the last corner to the starting corner.        Debug.DrawLine(startCorner, previousCorner);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Mathf-DeltaAngle"><a href="#Mathf-DeltaAngle" class="headerlink" title="Mathf.DeltaAngle"></a>Mathf.DeltaAngle</h4><p>计算两个给定角度（以度为单位给定）之间的最短差异。</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using UnityEngine;public class Example:MonoBehaviour{void Start(){// prints 90Debug.Log(Mathf.DeltaAngle(1080,90))}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Mathf-Exp"><a href="#Mathf-Exp" class="headerlink" title="Mathf.Exp"></a>Mathf.Exp</h4><p>返回 e 的制定幂</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using UnityEngine;public class Example:MonoBehaviour{void Start(){print(Mathf.Exp(6));}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Mathf-FloatToHalf"><a href="#Mathf-FloatToHalf" class="headerlink" title="Mathf.FloatToHalf"></a>Mathf.FloatToHalf</h4><p>返回无符号短整型（ushort）转换后的版精度浮点数，储存在16为无符号整数中</p><h4 id="Mathf-Floor"><a href="#Mathf-Floor" class="headerlink" title="Mathf.Floor"></a>Mathf.Floor</h4><p>返回小于或等于 f 的最大整数</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using UnityEngine;using System.Collections;public class ExampleClass：MonoBehaviour{void Example(){        Debug.Log(Mathf.Floor(10.0F));   // Prints  10        Debug.Log(Mathf.Floor(10.2F));   // Prints  10        Debug.Log(Mathf.Floor(10.7F));   // Prints  10        Debug.Log(Mathf.Floor(-10.0F));  // Prints -10        Debug.Log(Mathf.Floor(-10.2F));  // Prints -11        Debug.Log(Mathf.Floor(-10.7F));  // Prints -11}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Mathf-FloorToInt"><a href="#Mathf-FloorToInt" class="headerlink" title="Mathf.FloorToInt"></a>Mathf.FloorToInt</h4><p>返回小于或等于 f 的最大整数</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using unityEngine;using System.Collections;public class ExampleClass:MonoBehaviour{void Example(){Debug.Log(Mathf.FloorToInt(10.0F));  // Prints  10        Debug.Log(Mathf.FloorToInt(10.2F));  // Prints  10        Debug.Log(Mathf.FloorToInt(10.7F));  // Prints  10        Debug.Log(Mathf.FloorToInt(-10.0F)); // Prints -10        Debug.Log(Mathf.FloorToInt(-10.2F)); // Prints -11        Debug.Log(Mathf.FloorToInt(-10.7F)); // Prints -11}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Mathf-GammaToLinearSpace"><a href="#Mathf-GammaToLinearSpace" class="headerlink" title="Mathf.GammaToLinearSpace"></a>Mathf.GammaToLinearSpace</h4><p>将给定制从伽马（sRGB）转换为线性颜色空间</p><h4 id="Mathf-HalfToFloat"><a href="#Mathf-HalfToFloat" class="headerlink" title="Mathf.HalfToFloat"></a>Mathf.HalfToFloat</h4><p>返回 float 解码后的32为浮点数</p><h4 id="Mathf-InverseLerp"><a href="#Mathf-InverseLerp" class="headerlink" title="Mathf.InverseLerp"></a>Mathf.InverseLerp</h4><p>返回值为 float 返回了一个介于0和1之间的值。表示“value”参数在a和b定义的范围内的位置。</p><p>用于确定value位于a b两点之间的位置</p><h4 id="Mathf-IsPowerOfTwo"><a href="#Mathf-IsPowerOfTwo" class="headerlink" title="Mathf.IsPowerOfTwo"></a>Mathf.IsPowerOfTwo</h4><p>如果值是 2 的幂，则返回 true</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using unityEngine;public class Example:MonoBehaviour{void Start(){// prints flaseDebug.Log(Mathf.IsPowerOfTwo(7));// prints trueDebug.Log(Mathf.IsPowerOfTwo(32));}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Mathf-Lerp"><a href="#Mathf-Lerp" class="headerlink" title="Mathf.Lerp"></a>Mathf.Lerp</h4><p>在 a 和 b 之间按照 t 进行线性插值，参数 t 限制在范围[0,1]内。</p><p>当t=0时，返回a、当t=1时，返回b、当t=0.5时，返回a和b的中点。</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using UnityEngine;public class Example : MonoBehaviour{    // animate the game object from -1 to +1 and back    public float minimum = -1.0F;    public float maximum =  1.0F;    // starting value for the Lerp    static float t = 0.0f;    void Update()    {        // animate the position of the game object...        transform.position = new Vector3(Mathf.Lerp(minimum, maximum, t), 0, 0);        // .. and increase the t interpolater        t += 0.5f * Time.deltaTime;        // now check if the interpolator has reached 1.0        // and swap maximum and minimum so game object moves        // in the opposite direction.        if (t &gt; 1.0f)        {            float temp = maximum;            maximum = minimum;            minimum = temp;            t = 0.0f;        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Mathf-LerpAngle"><a href="#Mathf-LerpAngle" class="headerlink" title="Mathf.LerpAngle"></a>Mathf.LerpAngle</h4><p>用法和Lerp相同，确保了在360度时值的正确插入</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using UnityEngine;public class Example:MonoBehaviour{float minAngle=0.0f;float maxAngle=90.0f;void Update(){float angle=Mathf.LerpAngle(minAngle,maxAngle,Time.time);transform.eulerAngles=new Vector3(0,angle,0);}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Mathf-LerpUnclamped"><a href="#Mathf-LerpUnclamped" class="headerlink" title="Mathf.LerpUnclamped"></a>Mathf.LerpUnclamped</h4><p>在 a 与 b 之间按照 t 进行线性插值，t 没有限制。</p><p>参数t不受限制，支持基于a和b的值。如果t小于0或大于1，则LerpUnclamped生成 a 到 b 范围之外的返回值。</p><p>假设参数a=0.33f，并且b=1.5f，如果插值器t=-0.25f，则返回值为0.0375f</p><h4 id="Mathf-LinearToGammSpace"><a href="#Mathf-LinearToGammSpace" class="headerlink" title="Mathf.LinearToGammSpace"></a>Mathf.LinearToGammSpace</h4><p>将给定值从线性转换为伽马（sRGB）颜色空间</p><h4 id="Mathf-Log"><a href="#Mathf-Log" class="headerlink" title="Mathf.Log"></a>Mathf.Log</h4><p>返回指定的数字已制定的底数为底的对数</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using UnityEngine;public class ScriptExample:MonoBehaviour{void Start(){// logarithm of 6 in base 2// prints 2.584963Debug.Log(Mathf.Log(6,2));}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>返回指定的数字的自然（以e为底）对数</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using UnityEngine;public class ScriptExample:MonoBehaviour{void Start(){// natural logarithm of 100// prints 4.60517Debug.Log(Mathf.Log(100));}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Mathf-Log10"><a href="#Mathf-Log10" class="headerlink" title="Mathf.Log10"></a>Mathf.Log10</h4><p>返回指定的数字的以10为底的对数</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using UnityEngine;public class Example:MonoBehaviour{void Start(){// logarithm of 100 in base 10// Prints 2print(Mathf.Log10(100));}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Mathf-Max"><a href="#Mathf-Max" class="headerlink" title="Mathf.Max"></a>Mathf.Max</h4><p>返回两个或更多值中的最大值</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using UnityEngine;public class ScriptExample:MonoBehaviour{void Start(){// prints 2.4Debug.Log(Mathf.Max(1.2f,2.4f));}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Mathf-Min"><a href="#Mathf-Min" class="headerlink" title="Mathf.Min"></a>Mathf.Min</h4><p>返回两个或更多值中的最小值</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using UnityEngine;public class ScriptExample:MonoBehaviour{void Start(){// prints 1.2Debug.Log(Mathf.Min(1.2f,2.4f));}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Mathf-MobeTowards"><a href="#Mathf-MobeTowards" class="headerlink" title="Mathf.MobeTowards"></a>Mathf.MobeTowards</h4><p>该函数包括三个参数分别是current（当前值）、target（要向其靠近的值）、maxDelta（对值应用的最大变化）</p><p>用于将值current向target靠近，在本质上与Mathf.Lerp相同，但是该函数确保速度不超过maxDelta。在maxDelta为负数的时候将值推离target</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using UnityEngine;public class Example:Monobehaviour{float currStrength;float maxStrength;float recoveryRate;void Update(){currStrength=Mathf.MoveTowards(currStrength,maxStrength,recoveryRate*Time.dalteTime);}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Mathf-MoveTowardsAngle"><a href="#Mathf-MoveTowardsAngle" class="headerlink" title="Mathf.MoveTowardsAngle"></a>Mathf.MoveTowardsAngle</h4><p>用法与MoveTowards相同，但是在值环绕360度时确保值能正确插入。但是在该函数下负值的maxDelta不受支持，若要将current推离目标角度，应该改为向该角度加上180</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using UnityEngine;public class Example : MonoBehaviour{    float target = 270.0f;    float speed = 45.0f;    void Update()    {        float angle = Mathf.MoveTowardsAngle(transform.eulerAngles.y, target, speed * Time.deltaTime);        transform.eulerAngles = new Vector3(0, angle, 0);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Mathf-NextPowerOfTwo"><a href="#Mathf-NextPowerOfTwo" class="headerlink" title="Mathf.NextPowerOfTwo"></a>Mathf.NextPowerOfTwo</h4><p>返回大于或者等于参数的下一个2的幂</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using UnityEnginepublic class ExampleClass:MonoBehaviour{void Start(){        //Prints 8 to the console        Debug.Log(Mathf.NextPowerOfTwo(7));        //Prints 256 to the console        Debug.Log(Mathf.NextPowerOfTwo(139));        //Prints 256 to the console        Debug.Log(Mathf.NextPowerOfTwo(256));}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Mathf-PerlinNoise"><a href="#Mathf-PerlinNoise" class="headerlink" title="Mathf.PerlinNoise"></a>Mathf.PerlinNoise</h4><p>该函数会返回一个float介于0.0和1.0之间的值，作用是产生2D柏林噪声</p><blockquote><p>柏林噪声是在 2D 平面上生成的浮点值的伪随机图案（虽然 该方法普及到三维或更高维，不过未在 Unity 中实现）。 该噪声不包含每个点处的完全随机值，而是由 “波”组成，其值在图案中逐渐增大和减小。该噪声可以 用作纹理特效的基础，以及用于动画、生成地形高度贴图 和许多其他内容。</p><p>可以通过传递相应的 X 和 Y 坐标，对平面中的任何点进行采样。 相同坐标始终返回相同采样值，但是平面本质上无穷大， 因此可通过选择随机区域进行采样以便避免重复。</p></blockquote><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using UnityEngine;using System.Collections;// Create a texture and fill it with Perlin noise.// Try varying the xOrg, yOrg and scale values in the inspector// while in Play mode to see the effect they have on the noise.public class ExampleScript : MonoBehaviour{    // Width and height of the texture in pixels.    public int pixWidth;    public int pixHeight;    // The origin of the sampled area in the plane.    public float xOrg;    public float yOrg;    // The number of cycles of the basic noise pattern that are repeated    // over the width and height of the texture.    public float scale = 1.0F;    private Texture2D noiseTex;    private Color[] pix;    private Renderer rend;    void Start()    {        rend = GetComponent&lt;Renderer&gt;();        // Set up the texture and a Color array to hold pixels during processing.        noiseTex = new Texture2D(pixWidth, pixHeight);        pix = new Color[noiseTex.width * noiseTex.height];        rend.material.mainTexture = noiseTex;    }    void CalcNoise()    {        // For each pixel in the texture...        float y = 0.0F;        while (y &lt; noiseTex.height)        {            float x = 0.0F;            while (x &lt; noiseTex.width)            {                float xCoord = xOrg + x / noiseTex.width * scale;                float yCoord = yOrg + y / noiseTex.height * scale;                float sample = Mathf.PerlinNoise(xCoord, yCoord);                pix[(int)y * noiseTex.width + (int)x] = new Color(sample, sample, sample);                x++;            }            y++;        }        // Copy the pixel data to the texture and load it into the GPU.        noiseTex.SetPixels(pix);        noiseTex.Apply();    }    void Update()    {        CalcNoise();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>虽然噪声平面是二维的，但是可方便地通过图案 仅使用单条一维线（例如用于动画特效）。</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using UnityEngine;public class Example : MonoBehaviour{    // "Bobbing" animation from 1D Perlin noise.    // Range over which height varies.    float heightScale = 1.0f;    // Distance covered per second along X axis of Perlin plane.    float xScale = 1.0f;    void Update()    {        float height = heightScale * Mathf.PerlinNoise(Time.time * xScale, 0.0f);        Vector3 pos = transform.position;        pos.y = height;        transform.position = pos;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Mathf-PingPong"><a href="#Mathf-PingPong" class="headerlink" title="Mathf.PingPong"></a>Mathf.PingPong</h4><p>返回一个值，该值将在0与length之间递增或者递减，该函数要求值t为自递增值，与Time.time和Time.unscaledTime相似</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using UnityEngine;public class PingPongExample:MonoBehaviour{Light myLight;void Start(){myLight=GetComponent&lt;Light&gt;();}void Update(){myLight.intensity=Mathf.PingPong(Time.time,8);}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Mathf-Pow"><a href="#Mathf-Pow" class="headerlink" title="Mathf.Pow"></a>Mathf.Pow</h4><p>返回 f 的 p 次幂</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using UnityEngine; public class Example:MonoBehaviour{void Start(){print(Mathf.Pow(6,1.8f));}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Mathf-Repeat"><a href="#Mathf-Repeat" class="headerlink" title="Mathf.Repeat"></a>Mathf.Repeat</h4><p>对值 t 进行循环，使它不会大于长度，并且不会小于0，类似于取模运算符，该函数适用于浮点数，没有负数定义行为</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using UnityEngine;public class Example:MonoBehaviour{void Update(){// Set the x position to loop between 0 and 3transform.position=new Vector3(Mathf.Repeat(Time.time,3),transform.position.y,transform.position.z);}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Mathf-Round"><a href="#Mathf-Round" class="headerlink" title="Mathf.Round"></a>Mathf.Round</h4><p>返回舍入为最近整数的 f。如果数字结尾是.5从而使他处于两个整数正中间（其中一个是偶数，另一个是奇数），则返回偶数</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using UnityEngine;using System.Collections;public class ExampleClass : MonoBehaviour{    // Use this for initialization    void Start()    {        // Prints 10        Debug.Log(Mathf.Round(10.0f));        // Prints 10        Debug.Log(Mathf.Round(10.2f));        // Prints 11        Debug.Log(Mathf.Round(10.7f));        // Prints 10        Debug.Log(Mathf.Round(10.5f));        // Prints 12        Debug.Log(Mathf.Round(11.5f));        // Prints -10        Debug.Log(Mathf.Round(-10.0f));        // Prints -10        Debug.Log(Mathf.Round(-10.2f));        // Prints -11        Debug.Log(Mathf.Round(-10.7f));        // Prints -10        Debug.Log(Mathf.Round(-10.5f));        // Prints -12        Debug.Log(Mathf.Round(-11.5f));    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Mathf-Sign"><a href="#Mathf-Sign" class="headerlink" title="Mathf.Sign"></a>Mathf.Sign</h4><p>返回 f 的符号。当f为正数或者是0是，返回值为1，当f为负数时，返回值为-1</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using UnityEngine;public class Example:MonoBehaviour{void Start(){Debug.Log(Mathf.Sign(-10));Debug.Log(Mathf.Sign(10));}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Mathf-Sin"><a href="#Mathf-Sin" class="headerlink" title="Mathf.Sin"></a>Mathf.Sin</h4><p>返回一个介于-1与+1之间的返回值</p><p>用于返回角度 f 的正弦</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using UnityEngine;using System.Collections;public class PolyDrawExample : MonoBehaviour{    public int numberOfSides;    public float polygonRadius;    public Vector2 polygonCenter;    void Update()    {        DebugDrawPolygon(polygonCenter, polygonRadius, numberOfSides);    }    // Draw a polygon in the XY plane with a specfied position, number of sides    // and radius.    void DebugDrawPolygon(Vector2 center, float radius, int numSides)    {        // The corner that is used to start the polygon (parallel to the X axis).        Vector2 startCorner = new Vector2(radius, 0) + center;        // The "previous" corner point, initialised to the starting corner.        Vector2 previousCorner = startCorner;        // For each corner after the starting corner...        for (int i = 1; i &lt; numSides; i++)        {            // Calculate the angle of the corner in radians.            float cornerAngle = 2f * Mathf.PI / (float)numSides * i;            // Get the X and Y coordinates of the corner point.            Vector2 currentCorner = new Vector2(Mathf.Cos(cornerAngle) * radius, Mathf.Sin(cornerAngle) * radius) + center;            // Draw a side of the polygon by connecting the current corner to the previous one.            Debug.DrawLine(currentCorner, previousCorner);            // Having used the current corner, it now becomes the previous corner.            previousCorner = currentCorner;        }        // Draw the final side by connecting the last corner to the starting corner.        Debug.DrawLine(startCorner, previousCorner);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Mathf-SmoothDamp"><a href="#Mathf-SmoothDamp" class="headerlink" title="Mathf.SmoothDamp"></a>Mathf.SmoothDamp</h4><p>参数表：current当前位置、target尝试达到的目标、currentVelocity当前速度，此值由函数在每次调用时修改、smoothTime达到目标所需要的近似时间。值越小，达到目标的速度越快、maxSpeed可以选择允许限制最大速度、deltaTime自上次调用此函数以来的时间（默认情况下为Time.deltaTime）</p><p>该函数实现了随时间推移将一个值逐渐改变为所需目标的过程，值通过某个类似于弹簧阻尼的函数（它从不超过目标）进行平滑。该函数可以用于平滑任何类型的值 、位置、颜色、标量</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using UnityEngine;public class Example:MonoBehaviour{// Sommth towards the height of the targetTransform target;float smoothTime=0.3f;float yVelocity=0.0f;void Update(){float newPosition=Mathf.SmoothDamp(transform.position.y,target.position.y,ref yVelocity,smoothTime);transform.position=new Vector3(transform.position.x,newPosition,transform.position.z);}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Mathf-SmoothDampAngle"><a href="#Mathf-SmoothDampAngle" class="headerlink" title="Mathf.SmoothDampAngle"></a>Mathf.SmoothDampAngle</h4><p>参数表：current当前位置、target尝试达到的目标、currentVelocity当前速度，此值由函数在每次调用时修改、smoothTime达到目标所需要的近似时间。值越小，达到目标的速度越快、maxSpeed可以选择允许限制最大速度、deltaTime自上次调用此函数以来的时间（默认情况下为Time.deltaTime）</p><p>该函数实现了随着时间推移将以度为单位给定的角度逐渐改变为所需目标角度，值通过某个类似于弹簧阻尼的函数（它不会超过目标）进行平滑。该函数可以用于平滑任何类型的值、位置、颜色、标量。最常见的用法就是用于平滑跟随摄像机</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using UnityEngine;public class Example : MonoBehaviour{    //A simple smooth follow camera,    // that follows the targets forward direction    Transform target;    float smooth = 0.3f;    float distance = 5.0f;    float yVelocity = 0.0f;    void Update()    {        // Damp angle from current y-angle towards target y-angle        float yAngle = Mathf.SmoothDampAngle(transform.eulerAngles.y, target.eulerAngles.y, ref yVelocity, smooth);        // Position at the target        Vector3 position = target.position;        // Then offset by distance behind the new angle        position += Quaternion.Euler(0, yAngle, 0) * new Vector3(0, 0, -distance);        // Apply the position        transform.position = position;        // Look at the target        transform.LookAt(target);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Mathf-SmoothStep"><a href="#Mathf-SmoothStep" class="headerlink" title="Mathf.SmoothStep"></a>Mathf.SmoothStep</h4><p>在 min 与 max 之间进行插值，在限制处进行平滑</p><p>该函数采用与 Lerp 相似的方法在 min 和 max 之间进行插值。但是，插值会从起点逐渐加速，然后朝着终点减慢。者可以用于创建表现十分自然地动画、淡化和其他过度</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using UnityEngine;public class Example:MonoBehaviour{// Minimum and maximum values for the transitionfloat minimum=10.0f;float maximum=20.0f;// Time taken for the transitionfloat duration=5.0f;void Start(){// Make a note of the time the script startedstartTime=Time.time;}void Update(){// Calculate the fraction of the total duration that has passedfloat t=(Time.time-startTime)/duration;transform.position=new Vector3(Mathf.SmoothStep(minimum,maximum,t),0,0);}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Mathf-Sqrt"><a href="#Mathf-Sqrt" class="headerlink" title="Mathf.Sqrt"></a>Mathf.Sqrt</h4><p>返回 f 的平方根</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using UnityEngine;using System.Collections;public class ExampleClass:MonoBehaviour{    // The formula made famous by Pythagoras, also used internally by    // Vector3.Distance and several other standard functions.    float HypotenuseLength(float sideALength, float sideBLength)    {        return Mathf.Sqrt(sideALength * sideALength + sideBLength * sideBLength);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Mathf-Tan"><a href="#Mathf-Tan" class="headerlink" title="Mathf.Tan"></a>Mathf.Tan</h4><p>返回角度 f 的正切（以弧度为单位）</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using UnityEngine;using System.Collections;public class ExampleClass:MonoBehaviour{void Example(){print(Mathf.Tan(0.5F));}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> Unity </tag>
            
            <tag> 游戏开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity项目作业_直升机</title>
      <link href="/2022/09/03/unity-xiang-mu-zuo-ye-zhi-sheng-ji/"/>
      <url>/2022/09/03/unity-xiang-mu-zuo-ye-zhi-sheng-ji/</url>
      
        <content type="html"><![CDATA[<h3 id="课程要求"><a href="#课程要求" class="headerlink" title="课程要求"></a>课程要求</h3><p>该项目要求制作一个可以进行飞行的直升机，具体内容包括直升机的移动以及螺旋桨的转动两个模块</p><p>其中直升机的移动模块通过 transform.position 模块进行实现，螺旋桨转动通过 transform.Rotate 模块进行实现</p><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>项目使用Unity免费素材Police Helicopter中的Helicopter模型，该模型除主要机体外还分为Main_Rotor和Tail_Rotor两个螺旋桨。</p><h3 id="模型移动"><a href="#模型移动" class="headerlink" title="模型移动"></a>模型移动</h3><p>该项目模型移动通过了transform.Translate对模型的坐标进行移动从而实现整体模型的移动，并且移动模式通过if(Input.GetKey)函数来进行键盘输入判断，若接收相应按键则产生移动反馈。</p><h5 id="具体反馈如下："><a href="#具体反馈如下：" class="headerlink" title="具体反馈如下："></a>具体反馈如下：</h5><h6 id="Space：上升、LeftShift：下降、W：向前移动、S：向后移动、A：向左平移、D：向右平移、Z：向左转向、C：向右转向"><a href="#Space：上升、LeftShift：下降、W：向前移动、S：向后移动、A：向左平移、D：向右平移、Z：向左转向、C：向右转向" class="headerlink" title="Space：上升、LeftShift：下降、W：向前移动、S：向后移动、A：向左平移、D：向右平移、Z：向左转向、C：向右转向"></a>Space：上升、LeftShift：下降、W：向前移动、S：向后移动、A：向左平移、D：向右平移、Z：向左转向、C：向右转向</h6><h5 id="具体脚本如下："><a href="#具体脚本如下：" class="headerlink" title="具体脚本如下："></a>具体脚本如下：</h5><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// Helicopter.csusing System.Collections;using System.Collections.Generic;using UnityEngine;public class Helicopter : MonoBehaviour{    public float upSpeed = 10f;    public float forwardSpeed = 10f;    public float downSpeed = 10f;    public float leftSpeed = 10f;    public float rightSpeed = 10f;    public float leftRotate = 10f;    // Start is called before the first frame update    void Start()    {            }    // Update is called once per frame    void Update()    {        if(Input.GetKey(KeyCode.Space))        {            transform.Translate(Vector3.up * upSpeed * Time.deltaTime);        }        if(Input.GetKey(KeyCode.LeftShift))        {            transform.Translate(Vector3.down * downSpeed * Time.deltaTime);        }        if(Input.GetKey(KeyCode.W))        {            transform.Translate(Vector3.forward*forwardSpeed * Time.deltaTime);        }        if(Input.GetKey(KeyCode.S))        {            transform.Translate(Vector3.back*forwardSpeed * Time.deltaTime);        }        if (Input.GetKey(KeyCode.A))        {            transform.Translate(Vector3.left * leftSpeed * Time.deltaTime);        }        if (Input.GetKey(KeyCode.D))        {            transform.Translate(Vector3.right * leftSpeed * Time.deltaTime);        }        if(Input.GetKey(KeyCode.Z))        {            transform.Rotate(Vector3.up * leftRotate * Time.deltaTime);        }        if (Input.GetKey(KeyCode.C))        {            transform.Rotate(Vector3.down * leftRotate * Time.deltaTime);        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该项目的摄像机进行了自动跟随处理，具体脚本处理来源网络资源</p><h5 id="具体脚本如下：-1"><a href="#具体脚本如下：-1" class="headerlink" title="具体脚本如下："></a>具体脚本如下：</h5><pre class="line-numbers language-C#" data-language="C#"><code class="language-C#">// Camera_Demo.csusing System.Collections;using System.Collections.Generic;using UnityEngine;public class Camera_Demo : MonoBehaviour{    public Transform target;    public float distanceUp = 15f;    public float distanceAway = 10f;    public float smooth = 2f;    public float camDepthSmooth = 5f;    // Start is called before the first frame update    void Start()    {            }    // Update is called once per frame    void Update()    {        // 鼠标轴控制相机的远近        if ((Input.mouseScrollDelta.y &lt; 0 &amp;&amp; Camera.main.fieldOfView &gt;= 3) || Input.mouseScrollDelta.y &gt; 0 &amp;&amp; Camera.main.fieldOfView &lt;= 80)        {            Camera.main.fieldOfView += Input.mouseScrollDelta.y * camDepthSmooth * Time.deltaTime;        }    }    void LateUpdate()    {        //相机的位置        Vector3 disPos = target.position + Vector3.up * distanceUp - target.forward * distanceAway; transform.position = Vector3.Lerp(transform.position, disPos, Time.deltaTime * smooth);        //相机的角度        transform.LookAt(target.position);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>项目直升机双螺旋桨的旋转过程通过建立直升机螺旋桨对象propellerObj，通过transform.Rotate函数进行旋转。</p><h5 id="具体脚本代码如下："><a href="#具体脚本代码如下：" class="headerlink" title="具体脚本代码如下："></a>具体脚本代码如下：</h5><pre class="line-numbers language-C#" data-language="C#"><code class="language-C#">// Rotor_Main.cs// Rotor_Tail.csusing System.Collections;using System.Collections.Generic;using UnityEngine;public class Rotor_Main : MonoBehaviour{    /// &lt;summary&gt;    /// 直升机螺旋桨对象    /// &lt;/summary&gt;    public GameObject propellerObj;    // Start is called before the first frame update    void Start()    {            }    // Update is called once per frame    void Update()    {        propellerObj.transform.Rotate(Vector3.up * 2000 * Time.deltaTime);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="以下是项目具体运行以及部分操作演示"><a href="#以下是项目具体运行以及部分操作演示" class="headerlink" title="以下是项目具体运行以及部分操作演示"></a>以下是项目具体运行以及部分操作演示</h5><p><video src="E:\GitHubMatery\source\_posts\HelicopterDemo.mp4"></video></p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> Unity </tag>
            
            <tag> 游戏开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity游戏开发笔记</title>
      <link href="/2022/09/03/unity-you-xi-kai-fa-bi-ji/"/>
      <url>/2022/09/03/unity-you-xi-kai-fa-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="模型移动"><a href="#模型移动" class="headerlink" title="模型移动"></a>模型移动</h2><p>通过 transform.Translate 函数来对模型进行移动操作</p><p>实现如下</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">transform.Translate(Vector3.up*upSpeed*Time.deltaTime);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中在Vector3中对应的坐标可以通过以下操作对应</p><ul><li>back 对应 Vector3(0,0,-1)</li><li>down 对应 Vector3(0,-1,0)</li><li>forward 对应 Vector3(0,0,1)</li><li>left 对应 Vector3(-1,0,0)</li><li>one 对应 Vector3(1,1,1)</li><li>right 对应 Vector3(0,1,0)</li><li>up 对应 Vector3(0,1,0)</li><li>zero 对应 Vector3(0,0,0)</li></ul><p>通过 transform.Rotate 函数来对模型进行旋转操作</p><p>实现如下</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">propellerObj.transform.Rotate(Vector3.up*2000*Time.deltaTime)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="键盘接受与反馈"><a href="#键盘接受与反馈" class="headerlink" title="键盘接受与反馈"></a>键盘接受与反馈</h2><p>通过 Input.GetKey 来持续接受（按住）时返回true</p><p>通过 Input.GetKeyDown 来接受用户按下的那一帧返回true</p><p>通过 Input.GetKeyUp 来接受用户释放的那一帧返回true</p><p>实现如下</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">Input.GetKey(keyCode.space)Input.GetKeyDown(KeyCode.space)Input.GetKeyUp(KeyCode.space)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="读取上一帧所需要的时间实现移动"><a href="#读取上一帧所需要的时间实现移动" class="headerlink" title="读取上一帧所需要的时间实现移动"></a>读取上一帧所需要的时间实现移动</h2><p>通过 Time.deltaTime 函数来读取上一帧所用的时间（以秒为单位）</p><p>实现如下</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">propellerObj.transform.Rotate(Vector3.up*2000*Time.deltaTime)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="实现固定时间的运行方法"><a href="#实现固定时间的运行方法" class="headerlink" title="实现固定时间的运行方法"></a>实现固定时间的运行方法</h2><p>该方法实现了固定时间运行的方法，一般来说默认运行时0.02秒代表50帧，也就是一秒可以运行50次</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">void FivedUpdate(){}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="实现螺旋桨匀速启动的办法"><a href="#实现螺旋桨匀速启动的办法" class="headerlink" title="实现螺旋桨匀速启动的办法"></a>实现螺旋桨匀速启动的办法</h2><p>通过创建螺旋桨的初始速度以及螺旋桨加速度的方法，与Time.deltaTime乘积求和的方法实现螺旋桨的匀速启动</p><p>实现如下</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public GameObject rotorObj;// 螺旋桨物体public float rotSpeed=0f;// 螺旋桨初始速度public float rotAcceleration=5f;// 旋转加速度void Update(){rotSpeed+=rotAcceleration*Time.deltaTime;rotorObj.transform.Rotate(Vector3.up*rotSpeed*Time.deltaTime);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="通过接受键盘反馈来实现真假切换实现启动-x2F-关闭灯光"><a href="#通过接受键盘反馈来实现真假切换实现启动-x2F-关闭灯光" class="headerlink" title="通过接受键盘反馈来实现真假切换实现启动/关闭灯光"></a>通过接受键盘反馈来实现真假切换实现启动/关闭灯光</h2><p>利用取非来实现真假切换</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public GameObject lightObj;public bool islightOnOff=false;void Update(){if(Input.GetKeyDown(KetCode.B)){islightOnOff=!islightOnOff;// 利用取非来实现真假切换if(lightObj!=null)}{// SetActive用来激活物体lightObj.SetActive(islightOnOff);}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="C-怎么接收输出文字"><a href="#C-怎么接收输出文字" class="headerlink" title="C#怎么接收输出文字"></a>C#怎么接收输出文字</h2><p>接收文字实现如下</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">Console.ReadKey();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输出文字实现如下</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">Console.WriteLine();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="Switch开关语句的与枚举的使用"><a href="#Switch开关语句的与枚举的使用" class="headerlink" title="Switch开关语句的与枚举的使用"></a>Switch开关语句的与枚举的使用</h2><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 枚举部分public enum Status    {        ZeroEngine, // 停机状态        RunEngine,  // 启动状态        TakeOff,    // 起飞状态        FlyForward, //平飞状态        Landing // 降落状态    }// 使用部分 switch (helicopterStatus)   // 必须保证有明确的值        {            case Status.ZeroEngine:                print("飞机处于停机状态");                rotAcceleration = -200f;                break;            case Status.RunEngine:                print("飞机处于启动状态");                rotAcceleration = 200f;                break;            case Status.TakeOff:                print("飞机处于起飞状态");                transform.Translate(Vector3.up * 3f * Time.deltaTime);                rotAcceleration = 0f;                break;            case Status.FlyForward:                print("飞机处于平飞状态");                transform.Translate(Vector3.forward * 5f * Time.deltaTime);                break;            case Status.Landing:                print("飞机处于降落状态");                if (transform.position.y &gt;= 0)                {                    transform.Translate(Vector3.down * 3f * Time.deltaTime);                }                else                {                    rotAcceleration = -200f;                    isOnOff = false;                }                break;        }    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="定时器的使用"><a href="#定时器的使用" class="headerlink" title="定时器的使用"></a>定时器的使用</h2><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">//调用StartCoroutine(OnTime(0.5f));// 定义IEnumerator OnTime(float time)    {        while (true)        {            // yield是挂起cpu            yield return new WaitForSeconds(time);            // 生成怪物的方法            CreateMonsters(transform.position);        }    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="随机数生成"><a href="#随机数生成" class="headerlink" title="随机数生成"></a>随机数生成</h2><p>通过Random.Range()进行随机数的生成</p><p>实际使用如下</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">if (bombObj != null)        {            float x = Random.Range(-10f, 10f);            float z = Random.Range(-10f, 10f);            Instantiate(bombObj, pos + new Vector3(x, 0f, z), Quaternion.identity);   // 实例化        }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="指定位置生成物体"><a href="#指定位置生成物体" class="headerlink" title="指定位置生成物体"></a>指定位置生成物体</h2><p>通过Instantiate进行生成</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">Instantiate(brickObj, new Vector3(0f, 0.5f, 0f), Quaternion.identity);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以通过配合for循环可以生成一面墙等</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">for (int i = 0; i &lt; 10; i++)        {            for (int j = 0; j &lt; 10; j++)            {                Instantiate(brickObj, new Vector3(i, j+0.5f, 0f), Quaternion.identity);            }        } <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>也可以通过if判断实隔位生成</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">for(int i=0;i&lt;=10 ;i++)         {           if(i%2==0)           {               continue;           }           Instantiate(brickObj, new Vector3(i, 0.5f, 0f), Quaternion.identity);       }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="动画器基本操作"><a href="#动画器基本操作" class="headerlink" title="动画器基本操作"></a>动画器基本操作</h2><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 获取动画器void Start(){animator = GetComponent&lt;Animator&gt;();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 动画器的调用// 其中isAttack是设置的参数，true代表参数的值animator.SetBool("isAttack",true)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="数组的基本操作"><a href="#数组的基本操作" class="headerlink" title="数组的基本操作"></a>数组的基本操作</h2><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 数组的定义public GameObject[] mathName;// 给数组开辟内存mathName = new GameObject[n];// 数组实例化存放mathName[index++] = obj;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="触发器的基本操作"><a href="#触发器的基本操作" class="headerlink" title="触发器的基本操作"></a>触发器的基本操作</h2><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 当触发器进入事件的时候，只有当物体进入的时候执行一次private void OnTriggerEnter(Collider other){print("执行一次");}// 当触发器进入事件的时候，当物体进入时一直执行private void OnTriggerStay(Collider other){print("持续执行");}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="标签引用"><a href="#标签引用" class="headerlink" title="标签引用"></a>标签引用</h2><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 例如获取地图上带有Enemy标签物体的引用，并且存放到数组中enemyArrInMap = GameObject.FindGameObjectWithTag("Enemy");<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="返回距离玩家最近的敌人的实例"><a href="#返回距离玩家最近的敌人的实例" class="headerlink" title="返回距离玩家最近的敌人的实例"></a>返回距离玩家最近的敌人的实例</h2><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">GameObject MinDistanceToPlayer(GameObject[] objArr){float minSqrDistance=Mathf.Infinity;// Mathf.Infinity代表正无穷GamemObject closestObj = null;// 最近物体for(int i = 0;i&lt;enemyArrInMap.Length;i++){// 每个敌人的位置var enemyPos = objArr[i].transform.position;// 每个敌人与玩家的平方距离var sqrLength = (enemyPos - transform.position).sqrMagnitude;// 比较距离if(sqrLength &lt; minSqrDistance){// 替换较小的值minSqrDistance = sqrLength;closestObj = objArr[i];}}return closestObj;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> Unity </tag>
            
            <tag> 游戏开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一个全新的博客</title>
      <link href="/2022/09/03/yi-ge-quan-xin-de-bo-ke/"/>
      <url>/2022/09/03/yi-ge-quan-xin-de-bo-ke/</url>
      
        <content type="html"><![CDATA[<h1 id="白猫wHCat的博客"><a href="#白猫wHCat的博客" class="headerlink" title="白猫wHCat的博客"></a>白猫wHCat的博客</h1><h5 id="该博客建立于2022年9月1日，在后期将常态化更新学习编程开发技巧以及个人的学习记录。"><a href="#该博客建立于2022年9月1日，在后期将常态化更新学习编程开发技巧以及个人的学习记录。" class="headerlink" title="该博客建立于2022年9月1日，在后期将常态化更新学习编程开发技巧以及个人的学习记录。"></a>该博客建立于2022年9月1日，在后期将常态化更新学习编程开发技巧以及个人的学习记录。</h5><p>在该博客中，将主要更新C/C++开发，数据结构与算法，面经，考研，C#开发，游戏开发等多种软件工程有关文章，文章仅用于个人开发学习心得记录。</p>]]></content>
      
      
      <categories>
          
          <category> Diary </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
